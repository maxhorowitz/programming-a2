Issue: Safety violation

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       method "__init__" with argument () set to []
  file:              stacktest.hny
  start statement:   line=1 column=1
  end statement:     line=33 column=28
  source code:       import stack
  shared variables:  { }
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 52
  explanation:       jump over method definition: set program counter to 52
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/list.hny
  start statement:   line=2 column=1
  end statement:     line=2 column=20
  source code:       def subseq(s, b, e):
                     ^^^

Step 3:
  program counter:   52
  hvm code:          Push PC(55)
  explanation:       push constant PC(55)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(55)]

Step 4:
  program counter:   53
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (PC(55)) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   54
  hvm code:          Jump 371
  explanation:       jump over method definition: set program counter to 371
  start statement:   line=12 column=1
  end statement:     line=12 column=12
  source code:       def tail(s):
                     ^^^

Step 6:
  program counter:   371
  hvm code:          Push PC(374)
  explanation:       push constant PC(374)
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(374)]

Step 7:
  program counter:   372
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (PC(374)) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   373
  hvm code:          Jump 392
  explanation:       jump over method definition: set program counter to 392
  start statement:   line=16 column=1
  end statement:     line=16 column=26
  source code:       def multiplicity(bg, elt):
                     ^^^

Step 9:
  program counter:   392
  hvm code:          Push PC(395)
  explanation:       push constant PC(395)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(395)]

Step 10:
  program counter:   393
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (PC(395)) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   394
  hvm code:          Jump 414
  explanation:       jump over method definition: set program counter to 414
  start statement:   line=23 column=1
  end statement:     line=23 column=13
  source code:       def size(bg):
                     ^^^

Step 12:
  program counter:   414
  hvm code:          Push PC(417)
  explanation:       push constant PC(417)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(417)]

Step 13:
  program counter:   415
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (PC(417)) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   416
  hvm code:          Jump 433
  explanation:       jump over method definition: set program counter to 433
  start statement:   line=29 column=1
  end statement:     line=29 column=13
  source code:       def bmin(bg):
                     ^^^

Step 15:
  program counter:   433
  hvm code:          Push PC(436)
  explanation:       push constant PC(436)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(436)]

Step 16:
  program counter:   434
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (PC(436)) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   435
  hvm code:          Jump 461
  explanation:       jump over method definition: set program counter to 461
  start statement:   line=34 column=1
  end statement:     line=34 column=13
  source code:       def bmax(bg):
                     ^^^

Step 18:
  program counter:   461
  hvm code:          Push PC(464)
  explanation:       push constant PC(464)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(464)]

Step 19:
  program counter:   462
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (PC(464)) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   463
  hvm code:          Jump 490
  explanation:       jump over method definition: set program counter to 490
  start statement:   line=42 column=1
  end statement:     line=42 column=17
  source code:       def add(bg, elt):
                     ^^^

Step 21:
  program counter:   490
  hvm code:          Push PC(493)
  explanation:       push constant PC(493)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(493)]

Step 22:
  program counter:   491
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (PC(493)) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   492
  hvm code:          Jump 1303
  explanation:       jump over method definition: set program counter to 1303
  start statement:   line=50 column=1
  end statement:     line=50 column=20
  source code:       def remove(bg, elt):
                     ^^^

Step 24:
  program counter:   1303
  hvm code:          Push PC(944)
  explanation:       push program counter constant 944 ("Stack")
  file:              stacktest.hny
  start statement:   line=7 column=1
  end statement:     line=7 column=25
  source code:       s = stack.Stack(MAX_SIZE)
                         ^^^^^^^^^^^
  stack:             [{:}, PC(944)]

Step 25:
  program counter:   1304
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       s = stack.Stack(MAX_SIZE)
                                     ^^^^^^^^
  stack:             [{:}, PC(944), 2]

Step 26:
  program counter:   1305
  hvm code:          Apply
  explanation:       pop an argument (2) and a program counter value (944: "Stack") and call the method
  source code:       s = stack.Stack(MAX_SIZE)
                         ^^^^^^^^^^^^^^^^^^^^^
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 20898, 2]

Step 27:
  program counter:   944
  hvm code:          Frame Stack(l)
  explanation:       method "Stack" with argument l set to 2
  file:              stackmon.hny
  start statement:   line=3 column=1
  end statement:     line=3 column=13
  source code:       def Stack(l):
                     ^^^^^^^^^^^^^
  method variables:  { l: 2, result: None }
  stack:             [{:}, 20898, { "result": None }]

Step 28:
  program counter:   945
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=5 column=3
  end statement:     line=20 column=3
  source code:       .mutex: Lock(),
  method variables:  { l: 2 }

Step 29:
  program counter:   946
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=8 column=5
  end expression:    line=19 column=22
  stack:             [{:}, 20898, { "result": None }, {:}]

Step 30:
  program counter:   947
  hvm code:          Push "mutex"
  explanation:       push constant "mutex"
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex"]

Step 31:
  program counter:   948
  hvm code:          Push PC(679)
  explanation:       push program counter constant 679 ("Lock")
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", PC(679)]

Step 32:
  program counter:   949
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", PC(679), []]

Step 33:
  program counter:   950
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (679: "Lock") and call the method
  source code:       .mutex: Lock(),
  call trace:        __init__() --> Stack(2) --> Lock()
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, []]

Step 34:
  program counter:   679
  hvm code:          Frame Lock()
  explanation:       method "Lock" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=24 column=1
  end statement:     line=24 column=11
  source code:       def Lock():
                     ^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }]

Step 35:
  program counter:   680
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=27
  source code:       result = BinSema(False)
                              ^^^^^^^
  method variables:  { }

Step 36:
  program counter:   681
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  start expression:  line=25 column=14
  end expression:    line=25 column=20
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, PC(672)]

Step 37:
  program counter:   682
  hvm code:          Push False
  explanation:       push constant False
  source code:       result = BinSema(False)
                                      ^^^^^
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, PC(672), False]

Step 38:
  program counter:   683
  hvm code:          Apply
  explanation:       pop an argument (False) and a program counter value (672: "BinSema") and call the method
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Stack(2) --> Lock() --> BinSema(False)
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, 10946, False]

Step 39:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to False
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: False, result: None }
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, 10946, {:}]

Step 40:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: False }

Step 41:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (False) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, 10946, {:}, False]

Step 42:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 43:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, 10946, {:}]

Step 44:
  program counter:   677
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Stack(2) --> Lock()
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, False]

Step 45:
  program counter:   684
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  start statement:   line=25 column=5
  end statement:     line=25 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", 15218, { "l": 2 }]

Step 46:
  program counter:   685
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=24 column=1
  end statement:     line=24 column=11
  source code:       def Lock():
                     ^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 20898, { "result": None }, {:}, "mutex", False]

Step 47:
  program counter:   951
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "mutex", {:}); add key/value pair to dictionary; push result ({ "mutex": False })
  file:              stackmon.hny
  start statement:   line=5 column=3
  end statement:     line=20 column=3
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }]

Step 48:
  program counter:   952
  hvm code:          Push "push_cond"
  explanation:       push constant "push_cond"
  source code:       .push_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond"]

Step 49:
  program counter:   953
  hvm code:          Push PC(738)
  explanation:       push program counter constant 738 ("Condition")
  source code:       .push_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", PC(738)]

Step 50:
  program counter:   954
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .push_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", PC(738), []]

Step 51:
  program counter:   955
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (738: "Condition") and call the method
  source code:       .push_cond: Condition(),
  call trace:        __init__() --> Stack(2) --> Condition()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, []]

Step 52:
  program counter:   738
  hvm code:          Frame Condition()
  explanation:       method "Condition" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=42 column=1
  end statement:     line=42 column=16
  source code:       def Condition():
                     ^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }]

Step 53:
  program counter:   739
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^
  method variables:  { }

Step 54:
  program counter:   740
  hvm code:          Push PC(310)
  explanation:       push program counter constant 310 ("empty")
  start expression:  line=43 column=14
  end expression:    line=43 column=22
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, PC(310)]

Step 55:
  program counter:   741
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, PC(310), []]

Step 56:
  program counter:   742
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (310: "empty") and call the method
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  call trace:        __init__() --> Stack(2) --> Condition() --> empty()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, 11890, []]

Step 57:
  program counter:   310
  hvm code:          Frame empty()
  explanation:       method "empty" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=1 column=1
  end statement:     line=1 column=12
  source code:       def empty():
                     ^^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, 11890, {:}]

Step 58:
  program counter:   311
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=2 column=5
  end statement:     line=2 column=16
  source code:       result = {:}
                              ^^^
  method variables:  { }

Step 59:
  program counter:   312
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=2 column=14
  end expression:    line=2 column=16
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, 11890, {:}, {:}]

Step 60:
  program counter:   313
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable "result"
  source code:       result = {:}
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, 11890, {:}]

Step 61:
  program counter:   314
  hvm code:          Return
  explanation:       push result ({:}) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=1 column=12
  source code:       def empty():
                     ^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Stack(2) --> Condition()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }, {:}]

Step 62:
  program counter:   743
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable "result"
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", 15298, { "l": 2 }]

Step 63:
  program counter:   744
  hvm code:          Return
  explanation:       push result ({:}) and restore method variables
  start statement:   line=42 column=1
  end statement:     line=42 column=16
  source code:       def Condition():
                     ^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 20898, { "result": None }, { "mutex": False }, "push_cond", {:}]

Step 64:
  program counter:   956
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "push_cond", { "mutex": False }); add key/value pair to dictionary; push result ({ "mutex": False, "push_cond": {:} })
  file:              stackmon.hny
  start statement:   line=5 column=3
  end statement:     line=20 column=3
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }]

Step 65:
  program counter:   957
  hvm code:          Push "pop_cond"
  explanation:       push constant "pop_cond"
  source code:       .pop_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond"]

Step 66:
  program counter:   958
  hvm code:          Push PC(738)
  explanation:       push program counter constant 738 ("Condition")
  source code:       .pop_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", PC(738)]

Step 67:
  program counter:   959
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .pop_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", PC(738), []]

Step 68:
  program counter:   960
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (738: "Condition") and call the method
  source code:       .pop_cond: Condition(),
  call trace:        __init__() --> Stack(2) --> Condition()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, []]

Step 69:
  program counter:   738
  hvm code:          Frame Condition()
  explanation:       method "Condition" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=42 column=1
  end statement:     line=42 column=16
  source code:       def Condition():
                     ^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }]

Step 70:
  program counter:   739
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^
  method variables:  { }

Step 71:
  program counter:   740
  hvm code:          Push PC(310)
  explanation:       push program counter constant 310 ("empty")
  start expression:  line=43 column=14
  end expression:    line=43 column=22
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, PC(310)]

Step 72:
  program counter:   741
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, PC(310), []]

Step 73:
  program counter:   742
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (310: "empty") and call the method
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  call trace:        __init__() --> Stack(2) --> Condition() --> empty()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, 11890, []]

Step 74:
  program counter:   310
  hvm code:          Frame empty()
  explanation:       method "empty" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=1 column=1
  end statement:     line=1 column=12
  source code:       def empty():
                     ^^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, 11890, {:}]

Step 75:
  program counter:   311
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=2 column=5
  end statement:     line=2 column=16
  source code:       result = {:}
                              ^^^
  method variables:  { }

Step 76:
  program counter:   312
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=2 column=14
  end expression:    line=2 column=16
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, 11890, {:}, {:}]

Step 77:
  program counter:   313
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable "result"
  source code:       result = {:}
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, 11890, {:}]

Step 78:
  program counter:   314
  hvm code:          Return
  explanation:       push result ({:}) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=1 column=12
  source code:       def empty():
                     ^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Stack(2) --> Condition()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }, {:}]

Step 79:
  program counter:   743
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable "result"
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", 15378, { "l": 2 }]

Step 80:
  program counter:   744
  hvm code:          Return
  explanation:       push result ({:}) and restore method variables
  start statement:   line=42 column=1
  end statement:     line=42 column=16
  source code:       def Condition():
                     ^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "push_cond": {:} }, "pop_cond", {:}]

Step 81:
  program counter:   961
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "pop_cond", { "mutex": False, "push_cond": {:} }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_cond": {:}, "push_cond": {:} })
  file:              stackmon.hny
  start statement:   line=5 column=3
  end statement:     line=20 column=3
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }]

Step 82:
  program counter:   962
  hvm code:          Push "valid_cond"
  explanation:       push constant "valid_cond"
  source code:       .valid_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond"]

Step 83:
  program counter:   963
  hvm code:          Push PC(738)
  explanation:       push program counter constant 738 ("Condition")
  source code:       .valid_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", PC(738)]

Step 84:
  program counter:   964
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .valid_cond: Condition(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", PC(738), []]

Step 85:
  program counter:   965
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (738: "Condition") and call the method
  source code:       .valid_cond: Condition(),
  call trace:        __init__() --> Stack(2) --> Condition()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, []]

Step 86:
  program counter:   738
  hvm code:          Frame Condition()
  explanation:       method "Condition" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=42 column=1
  end statement:     line=42 column=16
  source code:       def Condition():
                     ^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }]

Step 87:
  program counter:   739
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       result = bag.empty()
                              ^^^^^^^^^
  method variables:  { }

Step 88:
  program counter:   740
  hvm code:          Push PC(310)
  explanation:       push program counter constant 310 ("empty")
  start expression:  line=43 column=14
  end expression:    line=43 column=22
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, PC(310)]

Step 89:
  program counter:   741
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       result = bag.empty()
                                       ^^
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, PC(310), []]

Step 90:
  program counter:   742
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (310: "empty") and call the method
  source code:       result = bag.empty()
                              ^^^^^^^^^^^
  call trace:        __init__() --> Stack(2) --> Condition() --> empty()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, 11890, []]

Step 91:
  program counter:   310
  hvm code:          Frame empty()
  explanation:       method "empty" with argument () set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=1 column=1
  end statement:     line=1 column=12
  source code:       def empty():
                     ^^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, 11890, {:}]

Step 92:
  program counter:   311
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=2 column=5
  end statement:     line=2 column=16
  source code:       result = {:}
                              ^^^
  method variables:  { }

Step 93:
  program counter:   312
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=2 column=14
  end expression:    line=2 column=16
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, 11890, {:}, {:}]

Step 94:
  program counter:   313
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable "result"
  source code:       result = {:}
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, 11890, {:}]

Step 95:
  program counter:   314
  hvm code:          Return
  explanation:       push result ({:}) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=1 column=12
  source code:       def empty():
                     ^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Stack(2) --> Condition()
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }, {:}]

Step 96:
  program counter:   743
  hvm code:          StoreVar result
  explanation:       pop value ({:}) and store locally in variable "result"
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=43 column=5
  end statement:     line=43 column=24
  source code:       result = bag.empty()
                     ^^^^^^^^
  method variables:  { result: {:} }
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", 15458, { "l": 2 }]

Step 97:
  program counter:   744
  hvm code:          Return
  explanation:       push result ({:}) and restore method variables
  start statement:   line=42 column=1
  end statement:     line=42 column=16
  source code:       def Condition():
                     ^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:} }, "valid_cond", {:}]

Step 98:
  program counter:   966
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({:}, "valid_cond", { "mutex": False, "pop_cond": {:}, "push_cond": {:} }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_cond": {:}, "push_cond": {:}, "valid_cond": {:} })
  file:              stackmon.hny
  start statement:   line=5 column=3
  end statement:     line=20 column=3
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "valid_cond": {:} }]

Step 99:
  program counter:   967
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       .stack: [],
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "valid_cond": {:} }, "stack"]

Step 100:
  program counter:   968
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .stack: [],
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "valid_cond": {:} }, "stack", []]

Step 101:
  program counter:   969
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([], "stack", { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "valid_cond": {:} }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_cond": {:}, "push_cond": {:}, "stack": [], "valid_cond": {:} })
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "stack": [], "valid_cond": {:} }]

Step 102:
  program counter:   970
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       .size: 0, # how do we make sure the max size is l
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "stack": [], "valid_cond": {:} }, "size"]

Step 103:
  program counter:   971
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .size: 0, # how do we make sure the max size is l
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "stack": [], "valid_cond": {:} }, "size", 0]

Step 104:
  program counter:   972
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "size", { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "stack": [], "valid_cond": {:} }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} })
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }]

Step 105:
  program counter:   973
  hvm code:          Push "max_size"
  explanation:       push constant "max_size"
  source code:       .max_size: l, # capture maxSize parameter
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }, "max_size"]

Step 106:
  program counter:   974
  hvm code:          LoadVar l
  explanation:       push value (2) of variable "l"
  source code:       .max_size: l, # capture maxSize parameter
  stack:             [{:}, 20898, { "result": None }, { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }, "max_size", 2]

Step 107:
  program counter:   975
  hvm code:          DelVar l
  explanation:       delete method variable l
  start expression:  line=16 column=16
  end expression:    line=16 column=16
  method variables:  { }

Step 108:
  program counter:   976
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (2, "max_size", { "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }); add key/value pair to dictionary; push result ({ "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} })
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }]

Step 109:
  program counter:   977
  hvm code:          Push "valid"
  explanation:       push constant "valid"
  source code:       .valid: 0,#+1 to this when '(' and -1 when ')'
  stack:             [{:}, 20898, { "result": None }, { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }, "valid"]

Step 110:
  program counter:   978
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .valid: 0,#+1 to this when '(' and -1 when ')'
  stack:             [{:}, 20898, { "result": None }, { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }, "valid", 0]

Step 111:
  program counter:   979
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "valid", { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid_cond": {:} }); add key/value pair to dictionary; push result ({ "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} })
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }]

Step 112:
  program counter:   980
  hvm code:          Push "ever_negative"
  explanation:       push constant "ever_negative"
  source code:       .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True
  stack:             [{:}, 20898, { "result": None }, { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }, "ever_negative"]

Step 113:
  program counter:   981
  hvm code:          Push False
  explanation:       push constant False
  source code:       .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True
  stack:             [{:}, 20898, { "result": None }, { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }, "ever_negative", False]

Step 114:
  program counter:   982
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "ever_negative", { "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }); add key/value pair to dictionary; push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} })
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }]

Step 115:
  program counter:   983
  hvm code:          Push "problem_index"
  explanation:       push constant "problem_index"
  source code:       .problem_index: -1
  stack:             [{:}, 20898, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }, "problem_index"]

Step 116:
  program counter:   984
  hvm code:          Push -1
  explanation:       push constant -1
  source code:       .problem_index: -1
  stack:             [{:}, 20898, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }, "problem_index", -1]

Step 117:
  program counter:   985
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (-1, "problem_index", { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }); add key/value pair to dictionary; push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} })
  source code:       .mutex: Lock(),
  stack:             [{:}, 20898, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }]

Step 118:
  program counter:   986
  hvm code:          StoreVar result
  explanation:       pop value ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }) and store locally in variable "result"
  source code:       result = {
  method variables:  { result: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} } }
  stack:             [{:}, 20898, { "result": None }]

Step 119:
  program counter:   987
  hvm code:          Return
  explanation:       push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }) and restore method variables
  start statement:   line=3 column=1
  end statement:     line=3 column=13
  source code:       def Stack(l):
                     ^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }]

Step 120:
  program counter:   1306
  hvm code:          Store s
  explanation:       pop value ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }) and store into variable s
  file:              stacktest.hny
  start statement:   line=7 column=1
  end statement:     line=7 column=25
  source code:       s = stack.Stack(MAX_SIZE)
                     ^^^
  shared variables:  { s: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} } }
  stack:             [{:}]

Step 121:
  program counter:   1307
  hvm code:          Jump 1373
  explanation:       jump over method definition: set program counter to 1373
  start statement:   line=9 column=1
  end statement:     line=9 column=26
  source code:       def push_test(self, char):
                     ^^^

Step 122:
  program counter:   1373
  hvm code:          Push { 1, 2 }
  explanation:       push constant { 1, 2 }
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }]

Step 123:
  program counter:   1374
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  stack:             [{:}, { 1, 2 }, 0]

Step 124:
  program counter:   1375
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1, 2 }); assign value (1) to i; push new index (1) and True
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1, 2 }, 1, True]

Step 125:
  program counter:   1376
  hvm code:          JumpCond False 1387
  explanation:       pop value (True), compare to False, and jump to 1387 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}, { 1, 2 }, 1]

Step 126:
  program counter:   1377
  hvm code:          Push PC(1308)
  explanation:       push program counter constant 1308 ("push_test")
  start statement:   line=27 column=5
  end statement:     line=27 column=27
  source code:       spawn push_test(i, "(")
                           ^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1308)]

Step 127:
  program counter:   1378
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1308), []]

Step 128:
  program counter:   1379
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn push_test(i, "(")
                                     ^
  stack:             [{:}, { 1, 2 }, 1, PC(1308), [], 1]

Step 129:
  program counter:   1380
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=27 column=21
  end expression:    line=27 column=21
  method variables:  { result: None }

Step 130:
  program counter:   1381
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1308), [ 1 ]]

Step 131:
  program counter:   1382
  hvm code:          Push "("
  explanation:       push constant "("
  source code:       spawn push_test(i, "(")
                                        ^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1308), [ 1 ], "("]

Step 132:
  program counter:   1383
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [1]); insert first value into the second; push result ([1, "("])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1308), [ 1, "(" ]]

Step 133:
  program counter:   1384
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, "(")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1308), [ 1, "(" ], {:}]

Step 134:
  program counter:   1385
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([1, "("]), and program counter (1308: "push_test"), and spawn thread
  start expression:  line=27 column=5
  end expression:    line=27 column=27
  stack:             [{:}, { 1, 2 }, 1]

Step 135:
  program counter:   1386
  hvm code:          Jump 1375
  explanation:       set program counter to 1375
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                                            ^

Step 136:
  program counter:   1375
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1, 2 }); assign value (2) to i; push new index (2) and True
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  method variables:  { i: 2, result: None }
  stack:             [{:}, { 1, 2 }, 2, True]

Step 137:
  program counter:   1376
  hvm code:          JumpCond False 1387
  explanation:       pop value (True), compare to False, and jump to 1387 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}, { 1, 2 }, 2]

Step 138:
  program counter:   1377
  hvm code:          Push PC(1308)
  explanation:       push program counter constant 1308 ("push_test")
  start statement:   line=27 column=5
  end statement:     line=27 column=27
  source code:       spawn push_test(i, "(")
                           ^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1308)]

Step 139:
  program counter:   1378
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1308), []]

Step 140:
  program counter:   1379
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       spawn push_test(i, "(")
                                     ^
  stack:             [{:}, { 1, 2 }, 2, PC(1308), [], 2]

Step 141:
  program counter:   1380
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=27 column=21
  end expression:    line=27 column=21
  method variables:  { result: None }

Step 142:
  program counter:   1381
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1308), [ 2 ]]

Step 143:
  program counter:   1382
  hvm code:          Push "("
  explanation:       push constant "("
  source code:       spawn push_test(i, "(")
                                        ^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1308), [ 2 ], "("]

Step 144:
  program counter:   1383
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [2]); insert first value into the second; push result ([2, "("])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1308), [ 2, "(" ]]

Step 145:
  program counter:   1384
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, "(")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1308), [ 2, "(" ], {:}]

Step 146:
  program counter:   1385
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([2, "("]), and program counter (1308: "push_test"), and spawn thread
  start expression:  line=27 column=5
  end expression:    line=27 column=27
  stack:             [{:}, { 1, 2 }, 2]

Step 147:
  program counter:   1386
  hvm code:          Jump 1375
  explanation:       set program counter to 1375
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                                            ^

Step 148:
  program counter:   1375
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 1, 2 }); out of range -> push False
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  stack:             [{:}, False]

Step 149:
  program counter:   1376
  hvm code:          JumpCond False 1387
  explanation:       pop value (False), compare to False, and jump to 1387 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}]

Step 150:
  program counter:   1387
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=28 column=1
  end statement:     line=28 column=25
  source code:       for i in {1..NPUSH_CLOSE}:
                               ^^^^^^^^^^^^^^

Step 151:
  program counter:   1388
  hvm code:          Push { 1 }
  explanation:       push constant { 1 }
  start expression:  line=28 column=11
  end expression:    line=28 column=24
  stack:             [{:}, { 1 }]

Step 152:
  program counter:   1389
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPUSH_CLOSE}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 153:
  program counter:   1390
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1 }, 1, True]

Step 154:
  program counter:   1391
  hvm code:          JumpCond False 1402
  explanation:       pop value (True), compare to False, and jump to 1402 if the same
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  stack:             [{:}, { 1 }, 1]

Step 155:
  program counter:   1392
  hvm code:          Push PC(1308)
  explanation:       push program counter constant 1308 ("push_test")
  start statement:   line=29 column=5
  end statement:     line=29 column=27
  source code:       spawn push_test(i, ")")
                           ^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1308)]

Step 156:
  program counter:   1393
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1308), []]

Step 157:
  program counter:   1394
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn push_test(i, ")")
                                     ^
  stack:             [{:}, { 1 }, 1, PC(1308), [], 1]

Step 158:
  program counter:   1395
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=29 column=21
  end expression:    line=29 column=21
  method variables:  { result: None }

Step 159:
  program counter:   1396
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1308), [ 1 ]]

Step 160:
  program counter:   1397
  hvm code:          Push ")"
  explanation:       push constant ")"
  source code:       spawn push_test(i, ")")
                                        ^^^
  stack:             [{:}, { 1 }, 1, PC(1308), [ 1 ], ")"]

Step 161:
  program counter:   1398
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (")", [1]); insert first value into the second; push result ([1, ")"])
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1308), [ 1, ")" ]]

Step 162:
  program counter:   1399
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, ")")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1308), [ 1, ")" ], {:}]

Step 163:
  program counter:   1400
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([1, ")"]), and program counter (1308: "push_test"), and spawn thread
  start expression:  line=29 column=5
  end expression:    line=29 column=27
  stack:             [{:}, { 1 }, 1]

Step 164:
  program counter:   1401
  hvm code:          Jump 1390
  explanation:       set program counter to 1390
  start statement:   line=28 column=1
  end statement:     line=28 column=25
  source code:       for i in {1..NPUSH_CLOSE}:
                                             ^

Step 165:
  program counter:   1390
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..NPUSH_CLOSE}:
                     ^^^
  stack:             [{:}, False]

Step 166:
  program counter:   1391
  hvm code:          JumpCond False 1402
  explanation:       pop value (False), compare to False, and jump to 1402 if the same
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  stack:             [{:}]

Step 167:
  program counter:   1402
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=30 column=1
  end statement:     line=30 column=18
  source code:       for i in {1..NPOP}:
                               ^^^^^^^

Step 168:
  program counter:   1403
  hvm code:          Push { 1 }
  explanation:       push constant { 1 }
  start expression:  line=30 column=11
  end expression:    line=30 column=17
  stack:             [{:}, { 1 }]

Step 169:
  program counter:   1404
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPOP}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 170:
  program counter:   1405
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1 }, 1, True]

Step 171:
  program counter:   1406
  hvm code:          JumpCond False 1413
  explanation:       pop value (True), compare to False, and jump to 1413 if the same
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  stack:             [{:}, { 1 }, 1]

Step 172:
  program counter:   1407
  hvm code:          Push PC(1337)
  explanation:       push program counter constant 1337 ("pop_test")
  start statement:   line=31 column=5
  end statement:     line=31 column=21
  source code:       spawn pop_test(i)
                           ^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1337)]

Step 173:
  program counter:   1408
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn pop_test(i)
                                    ^
  stack:             [{:}, { 1 }, 1, PC(1337), 1]

Step 174:
  program counter:   1409
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=31 column=20
  end expression:    line=31 column=20
  method variables:  { result: None }

Step 175:
  program counter:   1410
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn pop_test(i)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1337), 1, {:}]

Step 176:
  program counter:   1411
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument (1), and program counter (1337: "pop_test"), and spawn thread
  start expression:  line=31 column=5
  end expression:    line=31 column=21
  stack:             [{:}, { 1 }, 1]

Step 177:
  program counter:   1412
  hvm code:          Jump 1405
  explanation:       set program counter to 1405
  start statement:   line=30 column=1
  end statement:     line=30 column=18
  source code:       for i in {1..NPOP}:
                                      ^

Step 178:
  program counter:   1405
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..NPOP}:
                     ^^^
  stack:             [{:}, False]

Step 179:
  program counter:   1406
  hvm code:          JumpCond False 1413
  explanation:       pop value (False), compare to False, and jump to 1413 if the same
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  stack:             [{:}]

Step 180:
  program counter:   1413
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=33 column=1
  end statement:     line=33 column=21
  source code:       spawn validate_test()
                           ^^^^^^^^^^^^^

Step 181:
  program counter:   1414
  hvm code:          Push PC(1360)
  explanation:       push program counter constant 1360 ("validate_test")
  start expression:  line=33 column=7
  end expression:    line=33 column=19
  stack:             [{:}, PC(1360)]

Step 182:
  program counter:   1415
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       spawn validate_test()
                                        ^^
  stack:             [{:}, PC(1360), []]

Step 183:
  program counter:   1416
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn validate_test()
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1360), [], {:}]

Step 184:
  program counter:   1417
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([]), and program counter (1360: "validate_test"), and spawn thread
  start expression:  line=33 column=1
  end expression:    line=33 column=21
  stack:             [{:}]

Step 185:
  program counter:   1418
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=33 column=28
  source code:       import stack
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T2: push_test(2, "(")
mode:  runnable
stack: ['[ 2, "(" ]']
other threads:
  T0: pc=1418 terminated atomic __init__()
  T1: pc=1308 runnable push_test(1, "(")
  T3: pc=1308 runnable push_test(1, ")")
  T4: pc=1337 runnable pop_test(1)
  T5: pc=1360 runnable validate_test()
shared variables:
  s: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }
state id: 5
================================================

Step 186:
  program counter:   1308
  hvm code:          Frame push_test(self, char)
  explanation:       method "push_test" with argument (self, char) set to [2, "("]
  start statement:   line=9 column=1
  end statement:     line=9 column=26
  source code:       def push_test(self, char):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { char: "(", result: None, self: 2 }
  call trace:        push_test(2, "(")
  stack:             [{:}]

Step 187:
  program counter:   1309
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=10 column=5
  end statement:     line=10 column=34
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 188:
  program counter:   1310
  hvm code:          Push "call push"
  explanation:       push constant "call push"
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^
  stack:             [{:}, [], "call push"]

Step 189:
  program counter:   1311
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call push", []); insert first value into the second; push result (["call push"])
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call push" ]]

Step 190:
  program counter:   1312
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       print("call push", self, char)
                                        ^^^^
  stack:             [{:}, [ "call push" ], 2]

Step 191:
  program counter:   1313
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, ["call push"]); insert first value into the second; push result (["call push", 2])
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call push", 2 ]]

Step 192:
  program counter:   1314
  hvm code:          LoadVar char
  explanation:       push value ("(") of variable "char"
  source code:       print("call push", self, char)
                                              ^^^^
  stack:             [{:}, [ "call push", 2 ], "("]

Step 193:
  program counter:   1315
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", ["call push", 2]); insert first value into the second; push result (["call push", 2, "("])
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call push", 2, "(" ]]

Step 194:
  program counter:   1316
  hvm code:          Print
  explanation:       pop value (["call push", 2, "("]) and add to print log
  source code:       print("call push", self, char)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        push_test(2, "(")
  stack:             [{:}]

Step 195:
  program counter:   1317
  hvm code:          Push PC(989)
  explanation:       push program counter constant 989 ("push")
  start statement:   line=11 column=5
  end statement:     line=11 column=24
  source code:       stack.push(?s, char)
                     ^^^^^^^^^^
  stack:             [{:}, PC(989)]

Step 196:
  program counter:   1318
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       stack.push(?s, char)
                                ^^^^^^^^
  stack:             [{:}, PC(989), []]

Step 197:
  program counter:   1319
  hvm code:          Push ?s
  explanation:       push constant ?s
  source code:       stack.push(?s, char)
                                 ^
  stack:             [{:}, PC(989), [], ?s]

Step 198:
  program counter:   1320
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?s, []); insert first value into the second; push result ([?s])
  source code:       stack.push(?s, char)
                                ^^^^^^^^
  stack:             [{:}, PC(989), [ ?s ]]

Step 199:
  program counter:   1321
  hvm code:          LoadVar char
  explanation:       push value ("(") of variable "char"
  source code:       stack.push(?s, char)
                                    ^^^^
  stack:             [{:}, PC(989), [ ?s ], "("]

Step 200:
  program counter:   1322
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [?s]); insert first value into the second; push result ([?s, "("])
  source code:       stack.push(?s, char)
                                ^^^^^^^^
  stack:             [{:}, PC(989), [ ?s, "(" ]]

Step 201:
  program counter:   1323
  hvm code:          Apply
  explanation:       pop an argument ([?s, "("]) and a program counter value (989: "push") and call the method
  source code:       stack.push(?s, char)
                     ^^^^^^^^^^^^^^^^^^^^
  call trace:        push_test(2, "(") --> push(?s, "(")
  stack:             [{:}, 21186, [ ?s, "(" ]]

Step 202:
  program counter:   989
  hvm code:          Frame push(s, c)
  explanation:       method "push" with argument (s, c) set to [?s, "("]
  file:              stackmon.hny
  start statement:   line=23 column=1
  end statement:     line=23 column=15
  source code:       def push(s, c):
                     ^^^^^^^^^^^^^^^
  method variables:  { c: "(", result: None, s: ?s }
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }]

Step 203:
  program counter:   990
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=25 column=5
  end statement:     line=25 column=22
  source code:       acquire(?s->mutex)
                     ^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, PC(695)]

Step 204:
  program counter:   991
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       acquire(?s->mutex)
                              ^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, PC(695), ?s]

Step 205:
  program counter:   992
  hvm code:          Push "mutex"
  explanation:       push constant "mutex"
  source code:       acquire(?s->mutex)
                                 ^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, PC(695), ?s, "mutex"]

Step 206:
  program counter:   993
  hvm code:          Address
  explanation:       pop a key ("mutex") and an address (?s) and push the combined address (?s["mutex"])
  source code:       acquire(?s->mutex)
                              ^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, PC(695), ?s["mutex"]]

Step 207:
  program counter:   994
  hvm code:          Apply
  explanation:       pop an argument (?s["mutex"]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?s->mutex)
                     ^^^^^^^^^^^^^^^^^^
  call trace:        push_test(2, "(") --> push(?s, "(") --> acquire(?s["mutex"])
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, ?s["mutex"]]

Step 208:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?s["mutex"]
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?s["mutex"], result: None }
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }]

Step 209:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        push_test(2, "(") --> push(?s, "(") --> acquire(?s["mutex"])

Step 210:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 211:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?s["mutex"]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }, ?s["mutex"]]

Step 212:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?s["mutex"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }, False]

Step 213:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }, True]

Step 214:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }]

Step 215:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 216:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 217:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?s["mutex"]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }, ?s["mutex"]]

Step 218:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 219:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }, ?s["mutex"], True]

Step 220:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?s["mutex"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { s: { "ever_negative": False, "max_size": 2, "mutex": True, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} } }
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 15922, { "c": "(", "result": None, "s": ?s }]

Step 221:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 222:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: "(", result: None, s: ?s }
  call trace:        push_test(2, "(") --> push(?s, "(")
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, None]

Step 223:
  program counter:   995
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              stackmon.hny
  start statement:   line=25 column=5
  end statement:     line=25 column=22
  source code:       acquire(?s->mutex)
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }]

Step 224:
  program counter:   996
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  start statement:   line=26 column=5
  end statement:     line=26 column=33
  source code:       while s->size >= s->max_size:
                           ^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s]

Step 225:
  program counter:   997
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       while s->size >= s->max_size:
                              ^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s, "size"]

Step 226:
  program counter:   998
  hvm code:          Address
  explanation:       pop a key ("size") and an address (?s) and push the combined address (?s["size"])
  source code:       while s->size >= s->max_size:
                           ^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["size"]]

Step 227:
  program counter:   999
  hvm code:          Load
  explanation:       pop address of variable (?s["size"]) and push value (0)
  start expression:  line=26 column=11
  end expression:    line=26 column=17
  call trace:        push_test(2, "(") --> push(?s, "(")
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 0]

Step 228:
  program counter:   1000
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       while s->size >= s->max_size:
                                      ^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 0, ?s]

Step 229:
  program counter:   1001
  hvm code:          Push "max_size"
  explanation:       push constant "max_size"
  source code:       while s->size >= s->max_size:
                                         ^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 0, ?s, "max_size"]

Step 230:
  program counter:   1002
  hvm code:          Address
  explanation:       pop a key ("max_size") and an address (?s) and push the combined address (?s["max_size"])
  source code:       while s->size >= s->max_size:
                                      ^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 0, ?s["max_size"]]

Step 231:
  program counter:   1003
  hvm code:          Load
  explanation:       pop address of variable (?s["max_size"]) and push value (2)
  start expression:  line=26 column=22
  end expression:    line=26 column=32
  call trace:        push_test(2, "(") --> push(?s, "(")
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, 0, 2]

Step 232:
  program counter:   1004
  hvm code:          2-ary >=
  explanation:       pop 2 values (2, 0); check if second value is greater than or equal to the first; push result (False)
  source code:       while s->size >= s->max_size:
                           ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, False]

Step 233:
  program counter:   1005
  hvm code:          JumpCond False 1019
  explanation:       pop value (False), compare to False, and jump to 1019 if the same
  source code:       while s->size >= s->max_size:
                     ^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }]

Step 234:
  program counter:   1019
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  start statement:   line=29 column=5
  end statement:     line=29 column=40
  source code:       s->stack = list.append(?s->stack, c)
                     ^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s]

Step 235:
  program counter:   1020
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       s->stack = list.append(?s->stack, c)
                        ^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s, "stack"]

Step 236:
  program counter:   1021
  hvm code:          Address
  explanation:       pop a key ("stack") and an address (?s) and push the combined address (?s["stack"])
  source code:       s->stack = list.append(?s->stack, c)
                     ^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"]]

Step 237:
  program counter:   1022
  hvm code:          Push ?stack$list
  explanation:       push constant ?stack$list
  source code:       s->stack = list.append(?s->stack, c)
                                ^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list]

Step 238:
  program counter:   1023
  hvm code:          Push "append"
  explanation:       push constant "append"
  source code:       s->stack = list.append(?s->stack, c)
                                    ^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list, "append"]

Step 239:
  program counter:   1024
  hvm code:          Address
  explanation:       pop a key ("append") and an address (?stack$list) and push the combined address (?stack$list["append"])
  source code:       s->stack = list.append(?s->stack, c)
                                ^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"]]

Step 240:
  program counter:   1025
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       s->stack = list.append(?s->stack, c)
                                            ^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], []]

Step 241:
  program counter:   1026
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       s->stack = list.append(?s->stack, c)
                                             ^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], [], ?s]

Step 242:
  program counter:   1027
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       s->stack = list.append(?s->stack, c)
                                                ^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], [], ?s, "stack"]

Step 243:
  program counter:   1028
  hvm code:          Address
  explanation:       pop a key ("stack") and an address (?s) and push the combined address (?s["stack"])
  source code:       s->stack = list.append(?s->stack, c)
                                             ^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], [], ?s["stack"]]

Step 244:
  program counter:   1029
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?s["stack"], []); insert first value into the second; push result ([?s["stack"]])
  source code:       s->stack = list.append(?s->stack, c)
                                            ^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], [ ?s["stack"] ]]

Step 245:
  program counter:   1030
  hvm code:          LoadVar c
  explanation:       push value ("(") of variable "c"
  source code:       s->stack = list.append(?s->stack, c)
                                                       ^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], [ ?s["stack"] ], "("]

Step 246:
  program counter:   1031
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [?s["stack"]]); insert first value into the second; push result ([?s["stack"], "("])
  source code:       s->stack = list.append(?s->stack, c)
                                            ^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"], [ ?s["stack"], "(" ]]

Step 247:
  program counter:   1032
  hvm code:          Address
  explanation:       pop a key ([?s["stack"], "("]) and an address (?stack$list["append"]) and push the combined address (?stack$list["append"][[?s["stack"], "("]])
  source code:       s->stack = list.append(?s->stack, c)
                                ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"], ?stack$list["append"][[ ?s["stack"], "(" ]]]

Step 248:
  program counter:   1033
  hvm code:          Load
  explanation:       pop an address and push the value at the address
  start expression:  line=29 column=16
  end expression:    line=29 column=40
  call trace:        push_test(2, "(") --> push(?s, "(")
  new mode:          failed
  stack:             [{:}, 21186, { "char": "(", "result": None, "self": 2 }, ?s["stack"]]
  operation failed:  Load: unknown address ?stack$list["append"][[?s["stack"], "("]]

================================================
Final state
================================================
Threads:
  T0: pc=1418 terminated atomic __init__()
  T1: pc=1308 runnable push_test(1, "(")
  T2: pc=1033 failed push_test(2, "(") --> push(?s, "(")
  T3: pc=1308 runnable push_test(1, ")")
  T4: pc=1337 runnable pop_test(1)
  T5: pc=1360 runnable validate_test()
Variables:
  s: { "ever_negative": False, "max_size": 2, "mutex": True, "pop_cond": {:}, "problem_index": -1, "push_cond": {:}, "size": 0, "stack": [], "valid": 0, "valid_cond": {:} }
