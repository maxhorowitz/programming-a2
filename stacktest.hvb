Issue: Safety violation

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       method "__init__" with argument () set to []
  file:              stacktest.hny
  start statement:   line=1 column=1
  end statement:     line=33 column=28
  source code:       import stack
  shared variables:  { }
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 52
  explanation:       jump over method definition: set program counter to 52
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/list.hny
  start statement:   line=2 column=1
  end statement:     line=2 column=20
  source code:       def subseq(s, b, e):
                     ^^^

Step 3:
  program counter:   52
  hvm code:          Push PC(55)
  explanation:       push constant PC(55)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(55)]

Step 4:
  program counter:   53
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (PC(55)) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   54
  hvm code:          Jump 371
  explanation:       jump over method definition: set program counter to 371
  start statement:   line=12 column=1
  end statement:     line=12 column=12
  source code:       def tail(s):
                     ^^^

Step 6:
  program counter:   371
  hvm code:          Push PC(374)
  explanation:       push constant PC(374)
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(374)]

Step 7:
  program counter:   372
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (PC(374)) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   373
  hvm code:          Jump 392
  explanation:       jump over method definition: set program counter to 392
  start statement:   line=16 column=1
  end statement:     line=16 column=26
  source code:       def multiplicity(bg, elt):
                     ^^^

Step 9:
  program counter:   392
  hvm code:          Push PC(395)
  explanation:       push constant PC(395)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(395)]

Step 10:
  program counter:   393
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (PC(395)) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   394
  hvm code:          Jump 414
  explanation:       jump over method definition: set program counter to 414
  start statement:   line=23 column=1
  end statement:     line=23 column=13
  source code:       def size(bg):
                     ^^^

Step 12:
  program counter:   414
  hvm code:          Push PC(417)
  explanation:       push constant PC(417)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(417)]

Step 13:
  program counter:   415
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (PC(417)) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   416
  hvm code:          Jump 433
  explanation:       jump over method definition: set program counter to 433
  start statement:   line=29 column=1
  end statement:     line=29 column=13
  source code:       def bmin(bg):
                     ^^^

Step 15:
  program counter:   433
  hvm code:          Push PC(436)
  explanation:       push constant PC(436)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(436)]

Step 16:
  program counter:   434
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (PC(436)) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   435
  hvm code:          Jump 461
  explanation:       jump over method definition: set program counter to 461
  start statement:   line=34 column=1
  end statement:     line=34 column=13
  source code:       def bmax(bg):
                     ^^^

Step 18:
  program counter:   461
  hvm code:          Push PC(464)
  explanation:       push constant PC(464)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(464)]

Step 19:
  program counter:   462
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (PC(464)) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   463
  hvm code:          Jump 490
  explanation:       jump over method definition: set program counter to 490
  start statement:   line=42 column=1
  end statement:     line=42 column=17
  source code:       def add(bg, elt):
                     ^^^

Step 21:
  program counter:   490
  hvm code:          Push PC(493)
  explanation:       push constant PC(493)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(493)]

Step 22:
  program counter:   491
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (PC(493)) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   492
  hvm code:          Jump 1449
  explanation:       jump over method definition: set program counter to 1449
  start statement:   line=50 column=1
  end statement:     line=50 column=20
  source code:       def remove(bg, elt):
                     ^^^

Step 24:
  program counter:   1449
  hvm code:          Push PC(944)
  explanation:       push program counter constant 944 ("Stack")
  file:              stacktest.hny
  start statement:   line=7 column=1
  end statement:     line=7 column=25
  source code:       s = stack.Stack(MAX_SIZE)
                         ^^^^^^^^^^^
  stack:             [{:}, PC(944)]

Step 25:
  program counter:   1450
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       s = stack.Stack(MAX_SIZE)
                                     ^^^^^^^^
  stack:             [{:}, PC(944), 2]

Step 26:
  program counter:   1451
  hvm code:          Apply
  explanation:       pop an argument (2) and a program counter value (944: "Stack") and call the method
  source code:       s = stack.Stack(MAX_SIZE)
                         ^^^^^^^^^^^^^^^^^^^^^
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23234, 2]

Step 27:
  program counter:   944
  hvm code:          Frame Stack(l)
  explanation:       method "Stack" with argument l set to 2
  file:              stacksbs.hny
  start statement:   line=4 column=1
  end statement:     line=4 column=13
  source code:       def Stack(l):
                     ^^^^^^^^^^^^^
  method variables:  { l: 2, result: None }
  stack:             [{:}, 23234, { "result": None }]

Step 28:
  program counter:   945
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=6 column=3
  end statement:     line=22 column=3
  source code:       .mutex: BinSema(False), #main gate
  method variables:  { l: 2 }

Step 29:
  program counter:   946
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=9 column=5
  end expression:    line=20 column=22
  stack:             [{:}, 23234, { "result": None }, {:}]

Step 30:
  program counter:   947
  hvm code:          Push "mutex"
  explanation:       push constant "mutex"
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex"]

Step 31:
  program counter:   948
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", PC(672)]

Step 32:
  program counter:   949
  hvm code:          Push False
  explanation:       push constant False
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", PC(672), False]

Step 33:
  program counter:   950
  hvm code:          Apply
  explanation:       pop an argument (False) and a program counter value (672: "BinSema") and call the method
  source code:       .mutex: BinSema(False), #main gate
  call trace:        __init__() --> Stack(2) --> BinSema(False)
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", 15218, False]

Step 34:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to False
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: False, result: None }
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", 15218, { "l": 2 }]

Step 35:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: False }

Step 36:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (False) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, False]

Step 37:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 38:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", 15218, { "l": 2 }]

Step 39:
  program counter:   677
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23234, { "result": None }, {:}, "mutex", False]

Step 40:
  program counter:   951
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "mutex", {:}); add key/value pair to dictionary; push result ({ "mutex": False })
  file:              stacksbs.hny
  start statement:   line=6 column=3
  end statement:     line=22 column=3
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }]

Step 41:
  program counter:   952
  hvm code:          Push "push_gate"
  explanation:       push constant "push_gate"
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate"]

Step 42:
  program counter:   953
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}]

Step 43:
  program counter:   954
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema"]

Step 44:
  program counter:   955
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", PC(672)]

Step 45:
  program counter:   956
  hvm code:          Push True
  explanation:       push constant True
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", PC(672), True]

Step 46:
  program counter:   957
  hvm code:          Apply
  explanation:       pop an argument (True) and a program counter value (672: "BinSema") and call the method
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  call trace:        __init__() --> Stack(2) --> BinSema(True)
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, True]

Step 47:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to True
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: True, result: None }
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, { "l": 2 }]

Step 48:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: True }

Step 49:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (True) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, { "l": 2 }, True]

Step 50:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 51:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: True }
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, { "l": 2 }]

Step 52:
  program counter:   677
  hvm code:          Return
  explanation:       push result (True) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", True]

Step 53:
  program counter:   958
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  file:              stacksbs.hny
  start statement:   line=6 column=3
  end statement:     line=22 column=3
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", { "sema": True }]

Step 54:
  program counter:   959
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", { "sema": True }, "count"]

Step 55:
  program counter:   960
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", { "sema": True }, "count", 0]

Step 56:
  program counter:   961
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "sema": True }); add key/value pair to dictionary; push result ({ "count": 0, "sema": True })
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False }, "push_gate", { "count": 0, "sema": True }]

Step 57:
  program counter:   962
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({ "count": 0, "sema": True }, "push_gate", { "mutex": False }); add key/value pair to dictionary; push result ({ "mutex": False, "push_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }]

Step 58:
  program counter:   963
  hvm code:          Push "pop_gate"
  explanation:       push constant "pop_gate"
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate"]

Step 59:
  program counter:   964
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}]

Step 60:
  program counter:   965
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema"]

Step 61:
  program counter:   966
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", PC(672)]

Step 62:
  program counter:   967
  hvm code:          Push True
  explanation:       push constant True
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", PC(672), True]

Step 63:
  program counter:   968
  hvm code:          Apply
  explanation:       pop an argument (True) and a program counter value (672: "BinSema") and call the method
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  call trace:        __init__() --> Stack(2) --> BinSema(True)
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, True]

Step 64:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to True
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: True, result: None }
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, { "l": 2 }]

Step 65:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: True }

Step 66:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (True) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, { "l": 2 }, True]

Step 67:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 68:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: True }
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, { "l": 2 }]

Step 69:
  program counter:   677
  hvm code:          Return
  explanation:       push result (True) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", True]

Step 70:
  program counter:   969
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  file:              stacksbs.hny
  start statement:   line=6 column=3
  end statement:     line=22 column=3
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "sema": True }]

Step 71:
  program counter:   970
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "sema": True }, "count"]

Step 72:
  program counter:   971
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "sema": True }, "count", 0]

Step 73:
  program counter:   972
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "sema": True }); add key/value pair to dictionary; push result ({ "count": 0, "sema": True })
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "count": 0, "sema": True }]

Step 74:
  program counter:   973
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({ "count": 0, "sema": True }, "pop_gate", { "mutex": False, "push_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }]

Step 75:
  program counter:   974
  hvm code:          Push "validate_gate"
  explanation:       push constant "validate_gate"
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate"]

Step 76:
  program counter:   975
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}]

Step 77:
  program counter:   976
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema"]

Step 78:
  program counter:   977
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", PC(672)]

Step 79:
  program counter:   978
  hvm code:          Push True
  explanation:       push constant True
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", PC(672), True]

Step 80:
  program counter:   979
  hvm code:          Apply
  explanation:       pop an argument (True) and a program counter value (672: "BinSema") and call the method
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  call trace:        __init__() --> Stack(2) --> BinSema(True)
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, True]

Step 81:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to True
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: True, result: None }
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, { "l": 2 }]

Step 82:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: True }

Step 83:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (True) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, { "l": 2 }, True]

Step 84:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 85:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: True }
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, { "l": 2 }]

Step 86:
  program counter:   677
  hvm code:          Return
  explanation:       push result (True) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", True]

Step 87:
  program counter:   980
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  file:              stacksbs.hny
  start statement:   line=6 column=3
  end statement:     line=22 column=3
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "sema": True }]

Step 88:
  program counter:   981
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "sema": True }, "count"]

Step 89:
  program counter:   982
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "sema": True }, "count", 0]

Step 90:
  program counter:   983
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "sema": True }); add key/value pair to dictionary; push result ({ "count": 0, "sema": True })
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "count": 0, "sema": True }]

Step 91:
  program counter:   984
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({ "count": 0, "sema": True }, "validate_gate", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }]

Step 92:
  program counter:   985
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       .stack: [],
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }, "stack"]

Step 93:
  program counter:   986
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .stack: [],
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }, "stack", []]

Step 94:
  program counter:   987
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([], "stack", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }]

Step 95:
  program counter:   988
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       .size: 0, # how do we make sure the max size is l
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "size"]

Step 96:
  program counter:   989
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .size: 0, # how do we make sure the max size is l
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "size", 0]

Step 97:
  program counter:   990
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "size", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }]

Step 98:
  program counter:   991
  hvm code:          Push "max_size"
  explanation:       push constant "max_size"
  source code:       .max_size: l, # capture maxSize parameter
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "max_size"]

Step 99:
  program counter:   992
  hvm code:          LoadVar l
  explanation:       push value (2) of variable "l"
  source code:       .max_size: l, # capture maxSize parameter
  stack:             [{:}, 23234, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "max_size", 2]

Step 100:
  program counter:   993
  hvm code:          DelVar l
  explanation:       delete method variable l
  start expression:  line=17 column=16
  end expression:    line=17 column=16
  method variables:  { }

Step 101:
  program counter:   994
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (2, "max_size", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }]

Step 102:
  program counter:   995
  hvm code:          Push "valid"
  explanation:       push constant "valid"
  source code:       .valid: 0,#+1 to this when '(' and -1 when ')'
  stack:             [{:}, 23234, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "valid"]

Step 103:
  program counter:   996
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .valid: 0,#+1 to this when '(' and -1 when ')'
  stack:             [{:}, 23234, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "valid", 0]

Step 104:
  program counter:   997
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "valid", { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 105:
  program counter:   998
  hvm code:          Push "ever_negative"
  explanation:       push constant "ever_negative"
  source code:       .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True
  stack:             [{:}, 23234, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "ever_negative"]

Step 106:
  program counter:   999
  hvm code:          Push False
  explanation:       push constant False
  source code:       .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True
  stack:             [{:}, 23234, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "ever_negative", False]

Step 107:
  program counter:   1000
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "ever_negative", { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 108:
  program counter:   1001
  hvm code:          Push "problem_index"
  explanation:       push constant "problem_index"
  source code:       .problem_index: -1
  stack:             [{:}, 23234, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "problem_index"]

Step 109:
  program counter:   1002
  hvm code:          Push -1
  explanation:       push constant -1
  source code:       .problem_index: -1
  stack:             [{:}, 23234, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "problem_index", -1]

Step 110:
  program counter:   1003
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (-1, "problem_index", { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23234, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 111:
  program counter:   1004
  hvm code:          StoreVar result
  explanation:       pop value ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }) and store locally in variable "result"
  source code:       result = {
  method variables:  { result: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } } }
  stack:             [{:}, 23234, { "result": None }]

Step 112:
  program counter:   1005
  hvm code:          Return
  explanation:       push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }) and restore method variables
  start statement:   line=4 column=1
  end statement:     line=4 column=13
  source code:       def Stack(l):
                     ^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 113:
  program counter:   1452
  hvm code:          Store s
  explanation:       pop value ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }) and store into variable s
  file:              stacktest.hny
  start statement:   line=7 column=1
  end statement:     line=7 column=25
  source code:       s = stack.Stack(MAX_SIZE)
                     ^^^
  shared variables:  { s: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } } }
  stack:             [{:}]

Step 114:
  program counter:   1453
  hvm code:          Jump 1519
  explanation:       jump over method definition: set program counter to 1519
  start statement:   line=9 column=1
  end statement:     line=9 column=26
  source code:       def push_test(self, char):
                     ^^^

Step 115:
  program counter:   1519
  hvm code:          Push { 1, 2 }
  explanation:       push constant { 1, 2 }
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }]

Step 116:
  program counter:   1520
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  stack:             [{:}, { 1, 2 }, 0]

Step 117:
  program counter:   1521
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1, 2 }); assign value (1) to i; push new index (1) and True
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1, 2 }, 1, True]

Step 118:
  program counter:   1522
  hvm code:          JumpCond False 1533
  explanation:       pop value (True), compare to False, and jump to 1533 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}, { 1, 2 }, 1]

Step 119:
  program counter:   1523
  hvm code:          Push PC(1454)
  explanation:       push program counter constant 1454 ("push_test")
  start statement:   line=27 column=5
  end statement:     line=27 column=27
  source code:       spawn push_test(i, "(")
                           ^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1454)]

Step 120:
  program counter:   1524
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1454), []]

Step 121:
  program counter:   1525
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn push_test(i, "(")
                                     ^
  stack:             [{:}, { 1, 2 }, 1, PC(1454), [], 1]

Step 122:
  program counter:   1526
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=27 column=21
  end expression:    line=27 column=21
  method variables:  { result: None }

Step 123:
  program counter:   1527
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1454), [ 1 ]]

Step 124:
  program counter:   1528
  hvm code:          Push "("
  explanation:       push constant "("
  source code:       spawn push_test(i, "(")
                                        ^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1454), [ 1 ], "("]

Step 125:
  program counter:   1529
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [1]); insert first value into the second; push result ([1, "("])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1454), [ 1, "(" ]]

Step 126:
  program counter:   1530
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, "(")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1454), [ 1, "(" ], {:}]

Step 127:
  program counter:   1531
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([1, "("]), and program counter (1454: "push_test"), and spawn thread
  start expression:  line=27 column=5
  end expression:    line=27 column=27
  stack:             [{:}, { 1, 2 }, 1]

Step 128:
  program counter:   1532
  hvm code:          Jump 1521
  explanation:       set program counter to 1521
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                                            ^

Step 129:
  program counter:   1521
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1, 2 }); assign value (2) to i; push new index (2) and True
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  method variables:  { i: 2, result: None }
  stack:             [{:}, { 1, 2 }, 2, True]

Step 130:
  program counter:   1522
  hvm code:          JumpCond False 1533
  explanation:       pop value (True), compare to False, and jump to 1533 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}, { 1, 2 }, 2]

Step 131:
  program counter:   1523
  hvm code:          Push PC(1454)
  explanation:       push program counter constant 1454 ("push_test")
  start statement:   line=27 column=5
  end statement:     line=27 column=27
  source code:       spawn push_test(i, "(")
                           ^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1454)]

Step 132:
  program counter:   1524
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1454), []]

Step 133:
  program counter:   1525
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       spawn push_test(i, "(")
                                     ^
  stack:             [{:}, { 1, 2 }, 2, PC(1454), [], 2]

Step 134:
  program counter:   1526
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=27 column=21
  end expression:    line=27 column=21
  method variables:  { result: None }

Step 135:
  program counter:   1527
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1454), [ 2 ]]

Step 136:
  program counter:   1528
  hvm code:          Push "("
  explanation:       push constant "("
  source code:       spawn push_test(i, "(")
                                        ^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1454), [ 2 ], "("]

Step 137:
  program counter:   1529
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [2]); insert first value into the second; push result ([2, "("])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1454), [ 2, "(" ]]

Step 138:
  program counter:   1530
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, "(")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1454), [ 2, "(" ], {:}]

Step 139:
  program counter:   1531
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([2, "("]), and program counter (1454: "push_test"), and spawn thread
  start expression:  line=27 column=5
  end expression:    line=27 column=27
  stack:             [{:}, { 1, 2 }, 2]

Step 140:
  program counter:   1532
  hvm code:          Jump 1521
  explanation:       set program counter to 1521
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                                            ^

Step 141:
  program counter:   1521
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 1, 2 }); out of range -> push False
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  stack:             [{:}, False]

Step 142:
  program counter:   1522
  hvm code:          JumpCond False 1533
  explanation:       pop value (False), compare to False, and jump to 1533 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}]

Step 143:
  program counter:   1533
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=28 column=1
  end statement:     line=28 column=25
  source code:       for i in {1..NPUSH_CLOSE}:
                               ^^^^^^^^^^^^^^

Step 144:
  program counter:   1534
  hvm code:          Push { 1 }
  explanation:       push constant { 1 }
  start expression:  line=28 column=11
  end expression:    line=28 column=24
  stack:             [{:}, { 1 }]

Step 145:
  program counter:   1535
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPUSH_CLOSE}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 146:
  program counter:   1536
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1 }, 1, True]

Step 147:
  program counter:   1537
  hvm code:          JumpCond False 1548
  explanation:       pop value (True), compare to False, and jump to 1548 if the same
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  stack:             [{:}, { 1 }, 1]

Step 148:
  program counter:   1538
  hvm code:          Push PC(1454)
  explanation:       push program counter constant 1454 ("push_test")
  start statement:   line=29 column=5
  end statement:     line=29 column=27
  source code:       spawn push_test(i, ")")
                           ^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1454)]

Step 149:
  program counter:   1539
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1454), []]

Step 150:
  program counter:   1540
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn push_test(i, ")")
                                     ^
  stack:             [{:}, { 1 }, 1, PC(1454), [], 1]

Step 151:
  program counter:   1541
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=29 column=21
  end expression:    line=29 column=21
  method variables:  { result: None }

Step 152:
  program counter:   1542
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1454), [ 1 ]]

Step 153:
  program counter:   1543
  hvm code:          Push ")"
  explanation:       push constant ")"
  source code:       spawn push_test(i, ")")
                                        ^^^
  stack:             [{:}, { 1 }, 1, PC(1454), [ 1 ], ")"]

Step 154:
  program counter:   1544
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (")", [1]); insert first value into the second; push result ([1, ")"])
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1454), [ 1, ")" ]]

Step 155:
  program counter:   1545
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, ")")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1454), [ 1, ")" ], {:}]

Step 156:
  program counter:   1546
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([1, ")"]), and program counter (1454: "push_test"), and spawn thread
  start expression:  line=29 column=5
  end expression:    line=29 column=27
  stack:             [{:}, { 1 }, 1]

Step 157:
  program counter:   1547
  hvm code:          Jump 1536
  explanation:       set program counter to 1536
  start statement:   line=28 column=1
  end statement:     line=28 column=25
  source code:       for i in {1..NPUSH_CLOSE}:
                                             ^

Step 158:
  program counter:   1536
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..NPUSH_CLOSE}:
                     ^^^
  stack:             [{:}, False]

Step 159:
  program counter:   1537
  hvm code:          JumpCond False 1548
  explanation:       pop value (False), compare to False, and jump to 1548 if the same
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  stack:             [{:}]

Step 160:
  program counter:   1548
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=30 column=1
  end statement:     line=30 column=18
  source code:       for i in {1..NPOP}:
                               ^^^^^^^

Step 161:
  program counter:   1549
  hvm code:          Push { 1 }
  explanation:       push constant { 1 }
  start expression:  line=30 column=11
  end expression:    line=30 column=17
  stack:             [{:}, { 1 }]

Step 162:
  program counter:   1550
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPOP}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 163:
  program counter:   1551
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1 }, 1, True]

Step 164:
  program counter:   1552
  hvm code:          JumpCond False 1559
  explanation:       pop value (True), compare to False, and jump to 1559 if the same
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  stack:             [{:}, { 1 }, 1]

Step 165:
  program counter:   1553
  hvm code:          Push PC(1483)
  explanation:       push program counter constant 1483 ("pop_test")
  start statement:   line=31 column=5
  end statement:     line=31 column=21
  source code:       spawn pop_test(i)
                           ^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1483)]

Step 166:
  program counter:   1554
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn pop_test(i)
                                    ^
  stack:             [{:}, { 1 }, 1, PC(1483), 1]

Step 167:
  program counter:   1555
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=31 column=20
  end expression:    line=31 column=20
  method variables:  { result: None }

Step 168:
  program counter:   1556
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn pop_test(i)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1483), 1, {:}]

Step 169:
  program counter:   1557
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument (1), and program counter (1483: "pop_test"), and spawn thread
  start expression:  line=31 column=5
  end expression:    line=31 column=21
  stack:             [{:}, { 1 }, 1]

Step 170:
  program counter:   1558
  hvm code:          Jump 1551
  explanation:       set program counter to 1551
  start statement:   line=30 column=1
  end statement:     line=30 column=18
  source code:       for i in {1..NPOP}:
                                      ^

Step 171:
  program counter:   1551
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..NPOP}:
                     ^^^
  stack:             [{:}, False]

Step 172:
  program counter:   1552
  hvm code:          JumpCond False 1559
  explanation:       pop value (False), compare to False, and jump to 1559 if the same
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  stack:             [{:}]

Step 173:
  program counter:   1559
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=33 column=1
  end statement:     line=33 column=21
  source code:       spawn validate_test()
                           ^^^^^^^^^^^^^

Step 174:
  program counter:   1560
  hvm code:          Push PC(1506)
  explanation:       push program counter constant 1506 ("validate_test")
  start expression:  line=33 column=7
  end expression:    line=33 column=19
  stack:             [{:}, PC(1506)]

Step 175:
  program counter:   1561
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       spawn validate_test()
                                        ^^
  stack:             [{:}, PC(1506), []]

Step 176:
  program counter:   1562
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn validate_test()
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1506), [], {:}]

Step 177:
  program counter:   1563
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([]), and program counter (1506: "validate_test"), and spawn thread
  start expression:  line=33 column=1
  end expression:    line=33 column=21
  stack:             [{:}]

Step 178:
  program counter:   1564
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=33 column=28
  source code:       import stack
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T4: pop_test(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=1564 terminated atomic __init__()
  T1: pc=1454 runnable push_test(1, "(")
  T2: pc=1454 runnable push_test(2, "(")
  T3: pc=1454 runnable push_test(1, ")")
  T5: pc=1506 runnable validate_test()
shared variables:
  s: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }
state id: 3
================================================

Step 179:
  program counter:   1483
  hvm code:          Frame pop_test(self)
  explanation:       method "pop_test" with argument self set to 1
  start statement:   line=14 column=1
  end statement:     line=14 column=19
  source code:       def pop_test(self):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { result: None, self: 1 }
  call trace:        pop_test(1)
  stack:             [{:}]

Step 180:
  program counter:   1484
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=15 column=5
  end statement:     line=15 column=27
  source code:       print("call pop", self)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 181:
  program counter:   1485
  hvm code:          Push "call pop"
  explanation:       push constant "call pop"
  source code:       print("call pop", self)
                           ^^^^^^^^^^
  stack:             [{:}, [], "call pop"]

Step 182:
  program counter:   1486
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call pop", []); insert first value into the second; push result (["call pop"])
  source code:       print("call pop", self)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call pop" ]]

Step 183:
  program counter:   1487
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("call pop", self)
                                       ^^^^
  stack:             [{:}, [ "call pop" ], 1]

Step 184:
  program counter:   1488
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["call pop"]); insert first value into the second; push result (["call pop", 1])
  source code:       print("call pop", self)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call pop", 1 ]]

Step 185:
  program counter:   1489
  hvm code:          Print
  explanation:       pop value (["call pop", 1]) and add to print log
  source code:       print("call pop", self)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        pop_test(1)
  stack:             [{:}]

Step 186:
  program counter:   1490
  hvm code:          Push PC(1145)
  explanation:       push program counter constant 1145 ("pop")
  start statement:   line=16 column=5
  end statement:     line=16 column=25
  source code:       let v = stack.pop(?s):
                             ^^^^^^^^^
  stack:             [{:}, PC(1145)]

Step 187:
  program counter:   1491
  hvm code:          Push ?s
  explanation:       push constant ?s
  source code:       let v = stack.pop(?s):
                                        ^
  stack:             [{:}, PC(1145), ?s]

Step 188:
  program counter:   1492
  hvm code:          Apply
  explanation:       pop an argument (?s) and a program counter value (1145: "pop") and call the method
  source code:       let v = stack.pop(?s):
                             ^^^^^^^^^^^^^
  call trace:        pop_test(1) --> pop(?s)
  stack:             [{:}, 23890, ?s]

Step 189:
  program counter:   1145
  hvm code:          Frame pop(s)
  explanation:       method "pop" with argument s set to ?s
  file:              stacksbs.hny
  start statement:   line=46 column=1
  end statement:     line=46 column=11
  source code:       def pop(s):
                     ^^^^^^^^^^^
  method variables:  { result: None, s: ?s }
  stack:             [{:}, 23890, { "result": None, "self": 1 }]

Step 190:
  program counter:   1146
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=48 column=3
  end statement:     line=48 column=20
  source code:       acquire(?s->mutex)
                     ^^^^^^^
  method variables:  { s: ?s }

Step 191:
  program counter:   1147
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=48 column=3
  end expression:    line=48 column=9
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(695)]

Step 192:
  program counter:   1148
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       acquire(?s->mutex)
                              ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(695), ?s]

Step 193:
  program counter:   1149
  hvm code:          Push "mutex"
  explanation:       push constant "mutex"
  source code:       acquire(?s->mutex)
                                 ^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(695), ?s, "mutex"]

Step 194:
  program counter:   1150
  hvm code:          Address
  explanation:       pop a key ("mutex") and an address (?s) and push the combined address (?s["mutex"])
  source code:       acquire(?s->mutex)
                              ^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(695), ?s["mutex"]]

Step 195:
  program counter:   1151
  hvm code:          Apply
  explanation:       pop an argument (?s["mutex"]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?s->mutex)
                     ^^^^^^^^^^^^^^^^^^
  call trace:        pop_test(1) --> pop(?s) --> acquire(?s["mutex"])
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, ?s["mutex"]]

Step 196:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?s["mutex"]
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?s["mutex"], result: None }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }]

Step 197:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        pop_test(1) --> pop(?s) --> acquire(?s["mutex"])

Step 198:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 199:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?s["mutex"]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }, ?s["mutex"]]

Step 200:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?s["mutex"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }, False]

Step 201:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }, True]

Step 202:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }]

Step 203:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 204:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 205:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?s["mutex"]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }, ?s["mutex"]]

Step 206:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 207:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }, ?s["mutex"], True]

Step 208:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?s["mutex"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { s: { "ever_negative": False, "max_size": 2, "mutex": True, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } } }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 18434, { "s": ?s }]

Step 209:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 210:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { s: ?s }
  call trace:        pop_test(1) --> pop(?s)
  stack:             [{:}, 23890, { "result": None, "self": 1 }, None]

Step 211:
  program counter:   1152
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              stacksbs.hny
  start statement:   line=48 column=3
  end statement:     line=48 column=20
  source code:       acquire(?s->mutex)
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }]

Step 212:
  program counter:   1153
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  start statement:   line=49 column=3
  end statement:     line=49 column=17
  source code:       if s->size > 0:
                        ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, ?s]

Step 213:
  program counter:   1154
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       if s->size > 0:
                           ^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, ?s, "size"]

Step 214:
  program counter:   1155
  hvm code:          Address
  explanation:       pop a key ("size") and an address (?s) and push the combined address (?s["size"])
  source code:       if s->size > 0:
                        ^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, ?s["size"]]

Step 215:
  program counter:   1156
  hvm code:          Load
  explanation:       pop address of variable (?s["size"]) and push value (0)
  start expression:  line=49 column=6
  end expression:    line=49 column=12
  call trace:        pop_test(1) --> pop(?s)
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 0]

Step 216:
  program counter:   1157
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       if s->size > 0:
                                  ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 0, 0]

Step 217:
  program counter:   1158
  hvm code:          2-ary >
  explanation:       pop 2 values (0, 0); check if second value is greater than the first; push result (False)
  source code:       if s->size > 0:
                        ^^^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, False]

Step 218:
  program counter:   1159
  hvm code:          JumpCond False 1194
  explanation:       pop value (False), compare to False, and jump to 1194 if the same
  source code:       if s->size > 0:
                     ^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }]

Step 219:
  program counter:   1194
  hvm code:          Push PC(278)
  explanation:       push program counter constant 278 ("reversed")
  start statement:   line=55 column=3
  end statement:     line=55 column=35
  source code:       let rev = list.reversed(s->stack):
                               ^^^^^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(278)]

Step 220:
  program counter:   1195
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       let rev = list.reversed(s->stack):
                                             ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(278), ?s]

Step 221:
  program counter:   1196
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       let rev = list.reversed(s->stack):
                                                ^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(278), ?s, "stack"]

Step 222:
  program counter:   1197
  hvm code:          Address
  explanation:       pop a key ("stack") and an address (?s) and push the combined address (?s["stack"])
  source code:       let rev = list.reversed(s->stack):
                                             ^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(278), ?s["stack"]]

Step 223:
  program counter:   1198
  hvm code:          Load
  explanation:       pop address of variable (?s["stack"]) and push value ([])
  start expression:  line=55 column=27
  end expression:    line=55 column=34
  call trace:        pop_test(1) --> pop(?s)
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(278), []]

Step 224:
  program counter:   1199
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (278: "reversed") and call the method
  source code:       let rev = list.reversed(s->stack):
                               ^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        pop_test(1) --> pop(?s) --> reversed()
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, []]

Step 225:
  program counter:   278
  hvm code:          Frame reversed(d)
  explanation:       method "reversed" with argument d set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/list.hny
  start statement:   line=52 column=1
  end statement:     line=52 column=16
  source code:       def reversed(d):
                     ^^^^^^^^^^^^^^^^
  method variables:  { d: [], result: None }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }]

Step 226:
  program counter:   279
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=53 column=5
  end statement:     line=53 column=18
  source code:       let n = len(d):
                                 ^
  method variables:  { d: [] }

Step 227:
  program counter:   280
  hvm code:          LoadVar d
  explanation:       push value ([]) of variable "d"
  start expression:  line=53 column=17
  end expression:    line=53 column=17
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, []]

Step 228:
  program counter:   281
  hvm code:          1-ary len
  explanation:       pop a value ([]); push result (0)
  source code:       let n = len(d):
                             ^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, 0]

Step 229:
  program counter:   282
  hvm code:          StoreVar n
  explanation:       pop value (0) and store locally in variable "n"
  source code:       let n = len(d):
                     ^^^^^^^
  method variables:  { d: [], n: 0 }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }]

Step 230:
  program counter:   283
  hvm code:          Push ()
  explanation:       initialize accumulator for list comprehension: push constant ()
  start statement:   line=54 column=9
  end statement:     line=54 column=45
  source code:       result = [ d[n-i] for i in { 1..n } ]
                                ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, []]

Step 231:
  program counter:   284
  hvm code:          StoreVar $accu216
  explanation:       pop value ([]) and store locally in variable "$accu216"
  start expression:  line=54 column=20
  end expression:    line=54 column=43
  method variables:  { $accu216: [], d: [], n: 0 }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }]

Step 232:
  program counter:   285
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       result = [ d[n-i] for i in { 1..n } ]
                                                  ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, 1]

Step 233:
  program counter:   286
  hvm code:          LoadVar n
  explanation:       push value (0) of variable "n"
  source code:       result = [ d[n-i] for i in { 1..n } ]
                                                     ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, 1, 0]

Step 234:
  program counter:   287
  hvm code:          2-ary ..
  explanation:       pop 2 values (0, 1); range of integers; push result ({})
  source code:       result = [ d[n-i] for i in { 1..n } ]
                                                  ^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, {}]

Step 235:
  program counter:   288
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       result = [ d[n-i] for i in { 1..n } ]
                                ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, {}, 0]

Step 236:
  program counter:   289
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({}); out of range -> push False
  start expression:  line=54 column=20
  end expression:    line=54 column=20
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, False]

Step 237:
  program counter:   290
  hvm code:          JumpCond False 302
  explanation:       pop value (False), compare to False, and jump to 302 if the same
  start expression:  line=54 column=20
  end expression:    line=54 column=20
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }]

Step 238:
  program counter:   302
  hvm code:          DelVar d
  explanation:       delete method variable d
  source code:       result = [ d[n-i] for i in { 1..n } ]
                                ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { $accu216: [], n: 0 }

Step 239:
  program counter:   303
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=54 column=20
  end expression:    line=54 column=43

Step 240:
  program counter:   304
  hvm code:          DelVar n
  explanation:       delete method variable n
  start expression:  line=54 column=20
  end expression:    line=54 column=43
  method variables:  { $accu216: [] }

Step 241:
  program counter:   305
  hvm code:          LoadVar $accu216
  explanation:       push value ([]) of variable "$accu216"
  start expression:  line=54 column=20
  end expression:    line=54 column=43
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }, []]

Step 242:
  program counter:   306
  hvm code:          DelVar $accu216
  explanation:       delete method variable $accu216
  start expression:  line=54 column=20
  end expression:    line=54 column=43
  method variables:  { }

Step 243:
  program counter:   307
  hvm code:          StoreVar result
  explanation:       pop value ([]) and store locally in variable "result"
  source code:       result = [ d[n-i] for i in { 1..n } ]
                     ^^^^^^^^
  method variables:  { result: [] }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19202, { "s": ?s }]

Step 244:
  program counter:   308
  hvm code:          Return
  explanation:       push result ([]) and restore method variables
  start statement:   line=52 column=1
  end statement:     line=52 column=16
  source code:       def reversed(d):
                     ^^^^^^^^^^^^^^^^
  method variables:  { s: ?s }
  call trace:        pop_test(1) --> pop(?s)
  stack:             [{:}, 23890, { "result": None, "self": 1 }, []]

Step 245:
  program counter:   1200
  hvm code:          StoreVar rev
  explanation:       pop value ([]) and store locally in variable "rev"
  file:              stacksbs.hny
  start statement:   line=55 column=3
  end statement:     line=55 column=35
  source code:       let rev = list.reversed(s->stack):
                     ^^^^^^^^^
  method variables:  { rev: [], s: ?s }
  stack:             [{:}, 23890, { "result": None, "self": 1 }]

Step 246:
  program counter:   1201
  hvm code:          Push PC(44)
  explanation:       push program counter constant 44 ("head")
  start statement:   line=56 column=7
  end statement:     line=56 column=29
  source code:       result = list.head(rev)
                              ^^^^^^^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(44)]

Step 247:
  program counter:   1202
  hvm code:          LoadVar rev
  explanation:       push value ([]) of variable "rev"
  source code:       result = list.head(rev)
                                        ^^^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, PC(44), []]

Step 248:
  program counter:   1203
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (44: "head") and call the method
  source code:       result = list.head(rev)
                              ^^^^^^^^^^^^^^
  call trace:        pop_test(1) --> pop(?s) --> head()
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19266, []]

Step 249:
  program counter:   44
  hvm code:          Frame head(s)
  explanation:       method "head" with argument s set to []
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/list.hny
  start statement:   line=8 column=1
  end statement:     line=8 column=12
  source code:       def head(s):
                     ^^^^^^^^^^^^
  method variables:  { result: None, s: [] }
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19266, { "rev": [], "s": ?s }]

Step 250:
  program counter:   45
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=9 column=5
  end statement:     line=9 column=17
  source code:       result = s[0]
                              ^
  method variables:  { s: [] }

Step 251:
  program counter:   46
  hvm code:          LoadVar s
  explanation:       push value ([]) of variable "s"
  start expression:  line=9 column=14
  end expression:    line=9 column=14
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19266, { "rev": [], "s": ?s }, []]

Step 252:
  program counter:   47
  hvm code:          DelVar s
  explanation:       delete method variable s
  start expression:  line=9 column=14
  end expression:    line=9 column=14
  method variables:  { }

Step 253:
  program counter:   48
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       result = s[0]
                                ^
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19266, { "rev": [], "s": ?s }, [], 0]

Step 254:
  program counter:   49
  hvm code:          Apply
  explanation:       pop a pc or dictionary f and an index i and push f(i)
  source code:       result = s[0]
                              ^^^^
  new mode:          failed
  stack:             [{:}, 23890, { "result": None, "self": 1 }, 19266, { "rev": [], "s": ?s }]
  operation failed:  Index out of range

================================================
Final state
================================================
Threads:
  T0: pc=1564 terminated atomic __init__()
  T1: pc=1454 runnable push_test(1, "(")
  T2: pc=1454 runnable push_test(2, "(")
  T3: pc=1454 runnable push_test(1, ")")
  T4: pc=49 failed pop_test(1) --> pop(?s) --> head()
  T5: pc=1506 runnable validate_test()
Variables:
  s: { "ever_negative": False, "max_size": 2, "mutex": True, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }
