Issue: Safety violation

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       method "__init__" with argument () set to []
  file:              stacktest.hny
  start statement:   line=1 column=1
  end statement:     line=33 column=28
  source code:       import stack
  shared variables:  { }
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 52
  explanation:       jump over method definition: set program counter to 52
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/list.hny
  start statement:   line=2 column=1
  end statement:     line=2 column=20
  source code:       def subseq(s, b, e):
                     ^^^

Step 3:
  program counter:   52
  hvm code:          Push PC(55)
  explanation:       push constant PC(55)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(55)]

Step 4:
  program counter:   53
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (PC(55)) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   54
  hvm code:          Jump 371
  explanation:       jump over method definition: set program counter to 371
  start statement:   line=12 column=1
  end statement:     line=12 column=12
  source code:       def tail(s):
                     ^^^

Step 6:
  program counter:   371
  hvm code:          Push PC(374)
  explanation:       push constant PC(374)
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(374)]

Step 7:
  program counter:   372
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (PC(374)) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   373
  hvm code:          Jump 392
  explanation:       jump over method definition: set program counter to 392
  start statement:   line=16 column=1
  end statement:     line=16 column=26
  source code:       def multiplicity(bg, elt):
                     ^^^

Step 9:
  program counter:   392
  hvm code:          Push PC(395)
  explanation:       push constant PC(395)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(395)]

Step 10:
  program counter:   393
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (PC(395)) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   394
  hvm code:          Jump 414
  explanation:       jump over method definition: set program counter to 414
  start statement:   line=23 column=1
  end statement:     line=23 column=13
  source code:       def size(bg):
                     ^^^

Step 12:
  program counter:   414
  hvm code:          Push PC(417)
  explanation:       push constant PC(417)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(417)]

Step 13:
  program counter:   415
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (PC(417)) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   416
  hvm code:          Jump 433
  explanation:       jump over method definition: set program counter to 433
  start statement:   line=29 column=1
  end statement:     line=29 column=13
  source code:       def bmin(bg):
                     ^^^

Step 15:
  program counter:   433
  hvm code:          Push PC(436)
  explanation:       push constant PC(436)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(436)]

Step 16:
  program counter:   434
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (PC(436)) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   435
  hvm code:          Jump 461
  explanation:       jump over method definition: set program counter to 461
  start statement:   line=34 column=1
  end statement:     line=34 column=13
  source code:       def bmax(bg):
                     ^^^

Step 18:
  program counter:   461
  hvm code:          Push PC(464)
  explanation:       push constant PC(464)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(464)]

Step 19:
  program counter:   462
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (PC(464)) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   463
  hvm code:          Jump 490
  explanation:       jump over method definition: set program counter to 490
  start statement:   line=42 column=1
  end statement:     line=42 column=17
  source code:       def add(bg, elt):
                     ^^^

Step 21:
  program counter:   490
  hvm code:          Push PC(493)
  explanation:       push constant PC(493)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(493)]

Step 22:
  program counter:   491
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (PC(493)) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   492
  hvm code:          Jump 1443
  explanation:       jump over method definition: set program counter to 1443
  start statement:   line=50 column=1
  end statement:     line=50 column=20
  source code:       def remove(bg, elt):
                     ^^^

Step 24:
  program counter:   1443
  hvm code:          Push PC(944)
  explanation:       push program counter constant 944 ("Stack")
  file:              stacktest.hny
  start statement:   line=7 column=1
  end statement:     line=7 column=25
  source code:       s = stack.Stack(MAX_SIZE)
                         ^^^^^^^^^^^
  stack:             [{:}, PC(944)]

Step 25:
  program counter:   1444
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       s = stack.Stack(MAX_SIZE)
                                     ^^^^^^^^
  stack:             [{:}, PC(944), 2]

Step 26:
  program counter:   1445
  hvm code:          Apply
  explanation:       pop an argument (2) and a program counter value (944: "Stack") and call the method
  source code:       s = stack.Stack(MAX_SIZE)
                         ^^^^^^^^^^^^^^^^^^^^^
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23138, 2]

Step 27:
  program counter:   944
  hvm code:          Frame Stack(l)
  explanation:       method "Stack" with argument l set to 2
  file:              stacksbs.hny
  start statement:   line=3 column=1
  end statement:     line=3 column=13
  source code:       def Stack(l):
                     ^^^^^^^^^^^^^
  method variables:  { l: 2, result: None }
  stack:             [{:}, 23138, { "result": None }]

Step 28:
  program counter:   945
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=5 column=3
  end statement:     line=21 column=3
  source code:       .mutex: BinSema(False), #main gate
  method variables:  { l: 2 }

Step 29:
  program counter:   946
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=8 column=5
  end expression:    line=19 column=22
  stack:             [{:}, 23138, { "result": None }, {:}]

Step 30:
  program counter:   947
  hvm code:          Push "mutex"
  explanation:       push constant "mutex"
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex"]

Step 31:
  program counter:   948
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", PC(672)]

Step 32:
  program counter:   949
  hvm code:          Push False
  explanation:       push constant False
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", PC(672), False]

Step 33:
  program counter:   950
  hvm code:          Apply
  explanation:       pop an argument (False) and a program counter value (672: "BinSema") and call the method
  source code:       .mutex: BinSema(False), #main gate
  call trace:        __init__() --> Stack(2) --> BinSema(False)
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", 15218, False]

Step 34:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to False
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: False, result: None }
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", 15218, { "l": 2 }]

Step 35:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: False }

Step 36:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (False) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", 15218, { "l": 2 }, False]

Step 37:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 38:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", 15218, { "l": 2 }]

Step 39:
  program counter:   677
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23138, { "result": None }, {:}, "mutex", False]

Step 40:
  program counter:   951
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "mutex", {:}); add key/value pair to dictionary; push result ({ "mutex": False })
  file:              stacksbs.hny
  start statement:   line=5 column=3
  end statement:     line=21 column=3
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }]

Step 41:
  program counter:   952
  hvm code:          Push "push_gate"
  explanation:       push constant "push_gate"
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate"]

Step 42:
  program counter:   953
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}]

Step 43:
  program counter:   954
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema"]

Step 44:
  program counter:   955
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", PC(672)]

Step 45:
  program counter:   956
  hvm code:          Push True
  explanation:       push constant True
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", PC(672), True]

Step 46:
  program counter:   957
  hvm code:          Apply
  explanation:       pop an argument (True) and a program counter value (672: "BinSema") and call the method
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  call trace:        __init__() --> Stack(2) --> BinSema(True)
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, True]

Step 47:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to True
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: True, result: None }
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, { "l": 2 }]

Step 48:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: True }

Step 49:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (True) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, { "l": 2 }, True]

Step 50:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 51:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: True }
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", 15330, { "l": 2 }]

Step 52:
  program counter:   677
  hvm code:          Return
  explanation:       push result (True) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", {:}, "sema", True]

Step 53:
  program counter:   958
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  file:              stacksbs.hny
  start statement:   line=5 column=3
  end statement:     line=21 column=3
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", { "sema": True }]

Step 54:
  program counter:   959
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", { "sema": True }, "count"]

Step 55:
  program counter:   960
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", { "sema": True }, "count", 0]

Step 56:
  program counter:   961
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "sema": True }); add key/value pair to dictionary; push result ({ "count": 0, "sema": True })
  source code:       .push_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False }, "push_gate", { "count": 0, "sema": True }]

Step 57:
  program counter:   962
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({ "count": 0, "sema": True }, "push_gate", { "mutex": False }); add key/value pair to dictionary; push result ({ "mutex": False, "push_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }]

Step 58:
  program counter:   963
  hvm code:          Push "pop_gate"
  explanation:       push constant "pop_gate"
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate"]

Step 59:
  program counter:   964
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}]

Step 60:
  program counter:   965
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema"]

Step 61:
  program counter:   966
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", PC(672)]

Step 62:
  program counter:   967
  hvm code:          Push True
  explanation:       push constant True
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", PC(672), True]

Step 63:
  program counter:   968
  hvm code:          Apply
  explanation:       pop an argument (True) and a program counter value (672: "BinSema") and call the method
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  call trace:        __init__() --> Stack(2) --> BinSema(True)
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, True]

Step 64:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to True
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: True, result: None }
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, { "l": 2 }]

Step 65:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: True }

Step 66:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (True) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, { "l": 2 }, True]

Step 67:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 68:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: True }
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", 15506, { "l": 2 }]

Step 69:
  program counter:   677
  hvm code:          Return
  explanation:       push result (True) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", {:}, "sema", True]

Step 70:
  program counter:   969
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  file:              stacksbs.hny
  start statement:   line=5 column=3
  end statement:     line=21 column=3
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "sema": True }]

Step 71:
  program counter:   970
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "sema": True }, "count"]

Step 72:
  program counter:   971
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "sema": True }, "count", 0]

Step 73:
  program counter:   972
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "sema": True }); add key/value pair to dictionary; push result ({ "count": 0, "sema": True })
  source code:       .pop_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "push_gate": { "count": 0, "sema": True } }, "pop_gate", { "count": 0, "sema": True }]

Step 74:
  program counter:   973
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({ "count": 0, "sema": True }, "pop_gate", { "mutex": False, "push_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }]

Step 75:
  program counter:   974
  hvm code:          Push "validate_gate"
  explanation:       push constant "validate_gate"
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate"]

Step 76:
  program counter:   975
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}]

Step 77:
  program counter:   976
  hvm code:          Push "sema"
  explanation:       push constant "sema"
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema"]

Step 78:
  program counter:   977
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", PC(672)]

Step 79:
  program counter:   978
  hvm code:          Push True
  explanation:       push constant True
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", PC(672), True]

Step 80:
  program counter:   979
  hvm code:          Apply
  explanation:       pop an argument (True) and a program counter value (672: "BinSema") and call the method
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  call trace:        __init__() --> Stack(2) --> BinSema(True)
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, True]

Step 81:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to True
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: True, result: None }
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, { "l": 2 }]

Step 82:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: True }

Step 83:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (True) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, { "l": 2 }, True]

Step 84:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 85:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: True }
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", 15682, { "l": 2 }]

Step 86:
  program counter:   677
  hvm code:          Return
  explanation:       push result (True) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { l: 2 }
  call trace:        __init__() --> Stack(2)
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", {:}, "sema", True]

Step 87:
  program counter:   980
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (True, "sema", {:}); add key/value pair to dictionary; push result ({ "sema": True })
  file:              stacksbs.hny
  start statement:   line=5 column=3
  end statement:     line=21 column=3
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "sema": True }]

Step 88:
  program counter:   981
  hvm code:          Push "count"
  explanation:       push constant "count"
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "sema": True }, "count"]

Step 89:
  program counter:   982
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "sema": True }, "count", 0]

Step 90:
  program counter:   983
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "count", { "sema": True }); add key/value pair to dictionary; push result ({ "count": 0, "sema": True })
  source code:       .validate_gate: { .sema: BinSema(True), .count: 0 },
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }, "validate_gate", { "count": 0, "sema": True }]

Step 91:
  program counter:   984
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ({ "count": 0, "sema": True }, "validate_gate", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }]

Step 92:
  program counter:   985
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       .stack: [],
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }, "stack"]

Step 93:
  program counter:   986
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .stack: [],
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }, "stack", []]

Step 94:
  program counter:   987
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([], "stack", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }]

Step 95:
  program counter:   988
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       .size: 0, # how do we make sure the max size is l
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "size"]

Step 96:
  program counter:   989
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .size: 0, # how do we make sure the max size is l
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "size", 0]

Step 97:
  program counter:   990
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "size", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "stack": [], "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }]

Step 98:
  program counter:   991
  hvm code:          Push "max_size"
  explanation:       push constant "max_size"
  source code:       .max_size: l, # capture maxSize parameter
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "max_size"]

Step 99:
  program counter:   992
  hvm code:          LoadVar l
  explanation:       push value (2) of variable "l"
  source code:       .max_size: l, # capture maxSize parameter
  stack:             [{:}, 23138, { "result": None }, { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "max_size", 2]

Step 100:
  program counter:   993
  hvm code:          DelVar l
  explanation:       delete method variable l
  start expression:  line=16 column=16
  end expression:    line=16 column=16
  method variables:  { }

Step 101:
  program counter:   994
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (2, "max_size", { "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }]

Step 102:
  program counter:   995
  hvm code:          Push "valid"
  explanation:       push constant "valid"
  source code:       .valid: 0,#+1 to this when '(' and -1 when ')'
  stack:             [{:}, 23138, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "valid"]

Step 103:
  program counter:   996
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       .valid: 0,#+1 to this when '(' and -1 when ')'
  stack:             [{:}, 23138, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }, "valid", 0]

Step 104:
  program counter:   997
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (0, "valid", { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 105:
  program counter:   998
  hvm code:          Push "ever_negative"
  explanation:       push constant "ever_negative"
  source code:       .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True
  stack:             [{:}, 23138, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "ever_negative"]

Step 106:
  program counter:   999
  hvm code:          Push False
  explanation:       push constant False
  source code:       .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True
  stack:             [{:}, 23138, { "result": None }, { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "ever_negative", False]

Step 107:
  program counter:   1000
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "ever_negative", { "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 108:
  program counter:   1001
  hvm code:          Push "problem_index"
  explanation:       push constant "problem_index"
  source code:       .problem_index: -1
  stack:             [{:}, 23138, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "problem_index"]

Step 109:
  program counter:   1002
  hvm code:          Push -1
  explanation:       push constant -1
  source code:       .problem_index: -1
  stack:             [{:}, 23138, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }, "problem_index", -1]

Step 110:
  program counter:   1003
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (-1, "problem_index", { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }); add key/value pair to dictionary; push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } })
  source code:       .mutex: BinSema(False), #main gate
  stack:             [{:}, 23138, { "result": None }, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 111:
  program counter:   1004
  hvm code:          StoreVar result
  explanation:       pop value ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }) and store locally in variable "result"
  source code:       result = {
  method variables:  { result: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } } }
  stack:             [{:}, 23138, { "result": None }]

Step 112:
  program counter:   1005
  hvm code:          Return
  explanation:       push result ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }) and restore method variables
  start statement:   line=3 column=1
  end statement:     line=3 column=13
  source code:       def Stack(l):
                     ^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}, { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }]

Step 113:
  program counter:   1446
  hvm code:          Store s
  explanation:       pop value ({ "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }) and store into variable s
  file:              stacktest.hny
  start statement:   line=7 column=1
  end statement:     line=7 column=25
  source code:       s = stack.Stack(MAX_SIZE)
                     ^^^
  shared variables:  { s: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } } }
  stack:             [{:}]

Step 114:
  program counter:   1447
  hvm code:          Jump 1513
  explanation:       jump over method definition: set program counter to 1513
  start statement:   line=9 column=1
  end statement:     line=9 column=26
  source code:       def push_test(self, char):
                     ^^^

Step 115:
  program counter:   1513
  hvm code:          Push { 1, 2 }
  explanation:       push constant { 1, 2 }
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }]

Step 116:
  program counter:   1514
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  stack:             [{:}, { 1, 2 }, 0]

Step 117:
  program counter:   1515
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1, 2 }); assign value (1) to i; push new index (1) and True
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1, 2 }, 1, True]

Step 118:
  program counter:   1516
  hvm code:          JumpCond False 1527
  explanation:       pop value (True), compare to False, and jump to 1527 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}, { 1, 2 }, 1]

Step 119:
  program counter:   1517
  hvm code:          Push PC(1448)
  explanation:       push program counter constant 1448 ("push_test")
  start statement:   line=27 column=5
  end statement:     line=27 column=27
  source code:       spawn push_test(i, "(")
                           ^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1448)]

Step 120:
  program counter:   1518
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1448), []]

Step 121:
  program counter:   1519
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn push_test(i, "(")
                                     ^
  stack:             [{:}, { 1, 2 }, 1, PC(1448), [], 1]

Step 122:
  program counter:   1520
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=27 column=21
  end expression:    line=27 column=21
  method variables:  { result: None }

Step 123:
  program counter:   1521
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1448), [ 1 ]]

Step 124:
  program counter:   1522
  hvm code:          Push "("
  explanation:       push constant "("
  source code:       spawn push_test(i, "(")
                                        ^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1448), [ 1 ], "("]

Step 125:
  program counter:   1523
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [1]); insert first value into the second; push result ([1, "("])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1448), [ 1, "(" ]]

Step 126:
  program counter:   1524
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, "(")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, PC(1448), [ 1, "(" ], {:}]

Step 127:
  program counter:   1525
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([1, "("]), and program counter (1448: "push_test"), and spawn thread
  start expression:  line=27 column=5
  end expression:    line=27 column=27
  stack:             [{:}, { 1, 2 }, 1]

Step 128:
  program counter:   1526
  hvm code:          Jump 1515
  explanation:       set program counter to 1515
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                                            ^

Step 129:
  program counter:   1515
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1, 2 }); assign value (2) to i; push new index (2) and True
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  method variables:  { i: 2, result: None }
  stack:             [{:}, { 1, 2 }, 2, True]

Step 130:
  program counter:   1516
  hvm code:          JumpCond False 1527
  explanation:       pop value (True), compare to False, and jump to 1527 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}, { 1, 2 }, 2]

Step 131:
  program counter:   1517
  hvm code:          Push PC(1448)
  explanation:       push program counter constant 1448 ("push_test")
  start statement:   line=27 column=5
  end statement:     line=27 column=27
  source code:       spawn push_test(i, "(")
                           ^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1448)]

Step 132:
  program counter:   1518
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1448), []]

Step 133:
  program counter:   1519
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       spawn push_test(i, "(")
                                     ^
  stack:             [{:}, { 1, 2 }, 2, PC(1448), [], 2]

Step 134:
  program counter:   1520
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=27 column=21
  end expression:    line=27 column=21
  method variables:  { result: None }

Step 135:
  program counter:   1521
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1448), [ 2 ]]

Step 136:
  program counter:   1522
  hvm code:          Push "("
  explanation:       push constant "("
  source code:       spawn push_test(i, "(")
                                        ^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1448), [ 2 ], "("]

Step 137:
  program counter:   1523
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("(", [2]); insert first value into the second; push result ([2, "("])
  source code:       spawn push_test(i, "(")
                                     ^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1448), [ 2, "(" ]]

Step 138:
  program counter:   1524
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, "(")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, PC(1448), [ 2, "(" ], {:}]

Step 139:
  program counter:   1525
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([2, "("]), and program counter (1448: "push_test"), and spawn thread
  start expression:  line=27 column=5
  end expression:    line=27 column=27
  stack:             [{:}, { 1, 2 }, 2]

Step 140:
  program counter:   1526
  hvm code:          Jump 1515
  explanation:       set program counter to 1515
  start statement:   line=26 column=1
  end statement:     line=26 column=24
  source code:       for i in {1..NPUSH_OPEN}:
                                            ^

Step 141:
  program counter:   1515
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 1, 2 }); out of range -> push False
  source code:       for i in {1..NPUSH_OPEN}:
                     ^^^
  stack:             [{:}, False]

Step 142:
  program counter:   1516
  hvm code:          JumpCond False 1527
  explanation:       pop value (False), compare to False, and jump to 1527 if the same
  start expression:  line=26 column=1
  end expression:    line=26 column=3
  stack:             [{:}]

Step 143:
  program counter:   1527
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=28 column=1
  end statement:     line=28 column=25
  source code:       for i in {1..NPUSH_CLOSE}:
                               ^^^^^^^^^^^^^^

Step 144:
  program counter:   1528
  hvm code:          Push { 1 }
  explanation:       push constant { 1 }
  start expression:  line=28 column=11
  end expression:    line=28 column=24
  stack:             [{:}, { 1 }]

Step 145:
  program counter:   1529
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPUSH_CLOSE}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 146:
  program counter:   1530
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1 }, 1, True]

Step 147:
  program counter:   1531
  hvm code:          JumpCond False 1542
  explanation:       pop value (True), compare to False, and jump to 1542 if the same
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  stack:             [{:}, { 1 }, 1]

Step 148:
  program counter:   1532
  hvm code:          Push PC(1448)
  explanation:       push program counter constant 1448 ("push_test")
  start statement:   line=29 column=5
  end statement:     line=29 column=27
  source code:       spawn push_test(i, ")")
                           ^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1448)]

Step 149:
  program counter:   1533
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1448), []]

Step 150:
  program counter:   1534
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn push_test(i, ")")
                                     ^
  stack:             [{:}, { 1 }, 1, PC(1448), [], 1]

Step 151:
  program counter:   1535
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=29 column=21
  end expression:    line=29 column=21
  method variables:  { result: None }

Step 152:
  program counter:   1536
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, []); insert first value into the second; push result ([1])
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1448), [ 1 ]]

Step 153:
  program counter:   1537
  hvm code:          Push ")"
  explanation:       push constant ")"
  source code:       spawn push_test(i, ")")
                                        ^^^
  stack:             [{:}, { 1 }, 1, PC(1448), [ 1 ], ")"]

Step 154:
  program counter:   1538
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (")", [1]); insert first value into the second; push result ([1, ")"])
  source code:       spawn push_test(i, ")")
                                     ^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1448), [ 1, ")" ]]

Step 155:
  program counter:   1539
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn push_test(i, ")")
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1448), [ 1, ")" ], {:}]

Step 156:
  program counter:   1540
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([1, ")"]), and program counter (1448: "push_test"), and spawn thread
  start expression:  line=29 column=5
  end expression:    line=29 column=27
  stack:             [{:}, { 1 }, 1]

Step 157:
  program counter:   1541
  hvm code:          Jump 1530
  explanation:       set program counter to 1530
  start statement:   line=28 column=1
  end statement:     line=28 column=25
  source code:       for i in {1..NPUSH_CLOSE}:
                                             ^

Step 158:
  program counter:   1530
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..NPUSH_CLOSE}:
                     ^^^
  stack:             [{:}, False]

Step 159:
  program counter:   1531
  hvm code:          JumpCond False 1542
  explanation:       pop value (False), compare to False, and jump to 1542 if the same
  start expression:  line=28 column=1
  end expression:    line=28 column=3
  stack:             [{:}]

Step 160:
  program counter:   1542
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=30 column=1
  end statement:     line=30 column=18
  source code:       for i in {1..NPOP}:
                               ^^^^^^^

Step 161:
  program counter:   1543
  hvm code:          Push { 1 }
  explanation:       push constant { 1 }
  start expression:  line=30 column=11
  end expression:    line=30 column=17
  stack:             [{:}, { 1 }]

Step 162:
  program counter:   1544
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..NPOP}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 163:
  program counter:   1545
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 1 }, 1, True]

Step 164:
  program counter:   1546
  hvm code:          JumpCond False 1553
  explanation:       pop value (True), compare to False, and jump to 1553 if the same
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  stack:             [{:}, { 1 }, 1]

Step 165:
  program counter:   1547
  hvm code:          Push PC(1477)
  explanation:       push program counter constant 1477 ("pop_test")
  start statement:   line=31 column=5
  end statement:     line=31 column=21
  source code:       spawn pop_test(i)
                           ^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1477)]

Step 166:
  program counter:   1548
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn pop_test(i)
                                    ^
  stack:             [{:}, { 1 }, 1, PC(1477), 1]

Step 167:
  program counter:   1549
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=31 column=20
  end expression:    line=31 column=20
  method variables:  { result: None }

Step 168:
  program counter:   1550
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn pop_test(i)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, PC(1477), 1, {:}]

Step 169:
  program counter:   1551
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument (1), and program counter (1477: "pop_test"), and spawn thread
  start expression:  line=31 column=5
  end expression:    line=31 column=21
  stack:             [{:}, { 1 }, 1]

Step 170:
  program counter:   1552
  hvm code:          Jump 1545
  explanation:       set program counter to 1545
  start statement:   line=30 column=1
  end statement:     line=30 column=18
  source code:       for i in {1..NPOP}:
                                      ^

Step 171:
  program counter:   1545
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..NPOP}:
                     ^^^
  stack:             [{:}, False]

Step 172:
  program counter:   1546
  hvm code:          JumpCond False 1553
  explanation:       pop value (False), compare to False, and jump to 1553 if the same
  start expression:  line=30 column=1
  end expression:    line=30 column=3
  stack:             [{:}]

Step 173:
  program counter:   1553
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=33 column=1
  end statement:     line=33 column=21
  source code:       spawn validate_test()
                           ^^^^^^^^^^^^^

Step 174:
  program counter:   1554
  hvm code:          Push PC(1500)
  explanation:       push program counter constant 1500 ("validate_test")
  start expression:  line=33 column=7
  end expression:    line=33 column=19
  stack:             [{:}, PC(1500)]

Step 175:
  program counter:   1555
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       spawn validate_test()
                                        ^^
  stack:             [{:}, PC(1500), []]

Step 176:
  program counter:   1556
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn validate_test()
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1500), [], {:}]

Step 177:
  program counter:   1557
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([]), and program counter (1500: "validate_test"), and spawn thread
  start expression:  line=33 column=1
  end expression:    line=33 column=21
  stack:             [{:}]

Step 178:
  program counter:   1558
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=33 column=28
  source code:       import stack
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T3: push_test(1, ")")
mode:  runnable
stack: ['[ 1, ")" ]']
other threads:
  T0: pc=1558 terminated atomic __init__()
  T1: pc=1448 runnable push_test(1, "(")
  T2: pc=1448 runnable push_test(2, "(")
  T4: pc=1477 runnable pop_test(1)
  T5: pc=1500 runnable validate_test()
shared variables:
  s: { "ever_negative": False, "max_size": 2, "mutex": False, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }
state id: 4
================================================

Step 179:
  program counter:   1448
  hvm code:          Frame push_test(self, char)
  explanation:       method "push_test" with argument (self, char) set to [1, ")"]
  start statement:   line=9 column=1
  end statement:     line=9 column=26
  source code:       def push_test(self, char):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { char: ")", result: None, self: 1 }
  call trace:        push_test(1, ")")
  stack:             [{:}]

Step 180:
  program counter:   1449
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=10 column=5
  end statement:     line=10 column=34
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 181:
  program counter:   1450
  hvm code:          Push "call push"
  explanation:       push constant "call push"
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^
  stack:             [{:}, [], "call push"]

Step 182:
  program counter:   1451
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call push", []); insert first value into the second; push result (["call push"])
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call push" ]]

Step 183:
  program counter:   1452
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("call push", self, char)
                                        ^^^^
  stack:             [{:}, [ "call push" ], 1]

Step 184:
  program counter:   1453
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["call push"]); insert first value into the second; push result (["call push", 1])
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call push", 1 ]]

Step 185:
  program counter:   1454
  hvm code:          LoadVar char
  explanation:       push value (")") of variable "char"
  source code:       print("call push", self, char)
                                              ^^^^
  stack:             [{:}, [ "call push", 1 ], ")"]

Step 186:
  program counter:   1455
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (")", ["call push", 1]); insert first value into the second; push result (["call push", 1, ")"])
  source code:       print("call push", self, char)
                           ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call push", 1, ")" ]]

Step 187:
  program counter:   1456
  hvm code:          Print
  explanation:       pop value (["call push", 1, ")"]) and add to print log
  source code:       print("call push", self, char)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        push_test(1, ")")
  stack:             [{:}]

Step 188:
  program counter:   1457
  hvm code:          Push PC(1007)
  explanation:       push program counter constant 1007 ("push")
  start statement:   line=11 column=5
  end statement:     line=11 column=24
  source code:       stack.push(?s, char)
                     ^^^^^^^^^^
  stack:             [{:}, PC(1007)]

Step 189:
  program counter:   1458
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       stack.push(?s, char)
                                ^^^^^^^^
  stack:             [{:}, PC(1007), []]

Step 190:
  program counter:   1459
  hvm code:          Push ?s
  explanation:       push constant ?s
  source code:       stack.push(?s, char)
                                 ^
  stack:             [{:}, PC(1007), [], ?s]

Step 191:
  program counter:   1460
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?s, []); insert first value into the second; push result ([?s])
  source code:       stack.push(?s, char)
                                ^^^^^^^^
  stack:             [{:}, PC(1007), [ ?s ]]

Step 192:
  program counter:   1461
  hvm code:          LoadVar char
  explanation:       push value (")") of variable "char"
  source code:       stack.push(?s, char)
                                    ^^^^
  stack:             [{:}, PC(1007), [ ?s ], ")"]

Step 193:
  program counter:   1462
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (")", [?s]); insert first value into the second; push result ([?s, ")"])
  source code:       stack.push(?s, char)
                                ^^^^^^^^
  stack:             [{:}, PC(1007), [ ?s, ")" ]]

Step 194:
  program counter:   1463
  hvm code:          Apply
  explanation:       pop an argument ([?s, ")"]) and a program counter value (1007: "push") and call the method
  source code:       stack.push(?s, char)
                     ^^^^^^^^^^^^^^^^^^^^
  call trace:        push_test(1, ")") --> push(?s, ")")
  stack:             [{:}, 23426, [ ?s, ")" ]]

Step 195:
  program counter:   1007
  hvm code:          Frame push(s, c)
  explanation:       method "push" with argument (s, c) set to [?s, ")"]
  file:              stacksbs.hny
  start statement:   line=23 column=1
  end statement:     line=23 column=15
  source code:       def push(s, c):
                     ^^^^^^^^^^^^^^^
  method variables:  { c: ")", result: None, s: ?s }
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }]

Step 196:
  program counter:   1008
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=25 column=3
  end statement:     line=25 column=20
  source code:       acquire(?s->mutex)
                     ^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, PC(695)]

Step 197:
  program counter:   1009
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       acquire(?s->mutex)
                              ^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, PC(695), ?s]

Step 198:
  program counter:   1010
  hvm code:          Push "mutex"
  explanation:       push constant "mutex"
  source code:       acquire(?s->mutex)
                                 ^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, PC(695), ?s, "mutex"]

Step 199:
  program counter:   1011
  hvm code:          Address
  explanation:       pop a key ("mutex") and an address (?s) and push the combined address (?s["mutex"])
  source code:       acquire(?s->mutex)
                              ^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, PC(695), ?s["mutex"]]

Step 200:
  program counter:   1012
  hvm code:          Apply
  explanation:       pop an argument (?s["mutex"]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?s->mutex)
                     ^^^^^^^^^^^^^^^^^^
  call trace:        push_test(1, ")") --> push(?s, ")") --> acquire(?s["mutex"])
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, ?s["mutex"]]

Step 201:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?s["mutex"]
  file:              /opt/homebrew/lib/python3.10/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?s["mutex"], result: None }
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }]

Step 202:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        push_test(1, ")") --> push(?s, ")") --> acquire(?s["mutex"])

Step 203:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 204:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?s["mutex"]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }, ?s["mutex"]]

Step 205:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?s["mutex"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }, False]

Step 206:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }, True]

Step 207:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }]

Step 208:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 209:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 210:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?s["mutex"]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }, ?s["mutex"]]

Step 211:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 212:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }, ?s["mutex"], True]

Step 213:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?s["mutex"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { s: { "ever_negative": False, "max_size": 2, "mutex": True, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } } }
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, 16210, { "c": ")", "result": None, "s": ?s }]

Step 214:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 215:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { c: ")", result: None, s: ?s }
  call trace:        push_test(1, ")") --> push(?s, ")")
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, None]

Step 216:
  program counter:   1013
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              stacksbs.hny
  start statement:   line=25 column=3
  end statement:     line=25 column=20
  source code:       acquire(?s->mutex)
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }]

Step 217:
  program counter:   1014
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  start statement:   line=26 column=3
  end statement:     line=26 column=29
  source code:       if ?s->size < ?s->max_size:
                         ^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s]

Step 218:
  program counter:   1015
  hvm code:          Push "size"
  explanation:       push constant "size"
  source code:       if ?s->size < ?s->max_size:
                            ^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s, "size"]

Step 219:
  program counter:   1016
  hvm code:          Address
  explanation:       pop a key ("size") and an address (?s) and push the combined address (?s["size"])
  source code:       if ?s->size < ?s->max_size:
                         ^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["size"]]

Step 220:
  program counter:   1017
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       if ?s->size < ?s->max_size:
                                    ^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["size"], ?s]

Step 221:
  program counter:   1018
  hvm code:          Push "max_size"
  explanation:       push constant "max_size"
  source code:       if ?s->size < ?s->max_size:
                                       ^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["size"], ?s, "max_size"]

Step 222:
  program counter:   1019
  hvm code:          Address
  explanation:       pop a key ("max_size") and an address (?s) and push the combined address (?s["max_size"])
  source code:       if ?s->size < ?s->max_size:
                                    ^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["size"], ?s["max_size"]]

Step 223:
  program counter:   1020
  hvm code:          2-ary <
  explanation:       pop 2 values (?s["max_size"], ?s["size"]); check if second value is less than the first; push result (False)
  source code:       if ?s->size < ?s->max_size:
                        ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, False]

Step 224:
  program counter:   1021
  hvm code:          JumpCond False 1059
  explanation:       pop value (False), compare to False, and jump to 1059 if the same
  source code:       if ?s->size < ?s->max_size:
                     ^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }]

Step 225:
  program counter:   1059
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  start statement:   line=32 column=3
  end statement:     line=32 column=37
  source code:       s->stack = list.append(s->stack, c)
                     ^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s]

Step 226:
  program counter:   1060
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       s->stack = list.append(s->stack, c)
                        ^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s, "stack"]

Step 227:
  program counter:   1061
  hvm code:          Address
  explanation:       pop a key ("stack") and an address (?s) and push the combined address (?s["stack"])
  source code:       s->stack = list.append(s->stack, c)
                     ^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"]]

Step 228:
  program counter:   1062
  hvm code:          Push ?stack$list
  explanation:       push constant ?stack$list
  source code:       s->stack = list.append(s->stack, c)
                                ^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list]

Step 229:
  program counter:   1063
  hvm code:          Push "append"
  explanation:       push constant "append"
  source code:       s->stack = list.append(s->stack, c)
                                    ^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list, "append"]

Step 230:
  program counter:   1064
  hvm code:          Address
  explanation:       pop a key ("append") and an address (?stack$list) and push the combined address (?stack$list["append"])
  source code:       s->stack = list.append(s->stack, c)
                                ^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"]]

Step 231:
  program counter:   1065
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       s->stack = list.append(s->stack, c)
                                            ^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], []]

Step 232:
  program counter:   1066
  hvm code:          LoadVar s
  explanation:       push value (?s) of variable "s"
  source code:       s->stack = list.append(s->stack, c)
                                            ^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [], ?s]

Step 233:
  program counter:   1067
  hvm code:          Push "stack"
  explanation:       push constant "stack"
  source code:       s->stack = list.append(s->stack, c)
                                               ^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [], ?s, "stack"]

Step 234:
  program counter:   1068
  hvm code:          Address
  explanation:       pop a key ("stack") and an address (?s) and push the combined address (?s["stack"])
  source code:       s->stack = list.append(s->stack, c)
                                            ^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [], ?s["stack"]]

Step 235:
  program counter:   1069
  hvm code:          Load
  explanation:       pop address of variable (?s["stack"]) and push value ([])
  start expression:  line=32 column=26
  end expression:    line=32 column=33
  call trace:        push_test(1, ")") --> push(?s, ")")
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [], []]

Step 236:
  program counter:   1070
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([], []); insert first value into the second; push result ([[]])
  source code:       s->stack = list.append(s->stack, c)
                                            ^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [ [] ]]

Step 237:
  program counter:   1071
  hvm code:          LoadVar c
  explanation:       push value (")") of variable "c"
  source code:       s->stack = list.append(s->stack, c)
                                                      ^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [ [] ], ")"]

Step 238:
  program counter:   1072
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (")", [[]]); insert first value into the second; push result ([[], ")"])
  source code:       s->stack = list.append(s->stack, c)
                                            ^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"], [ [], ")" ]]

Step 239:
  program counter:   1073
  hvm code:          Address
  explanation:       pop a key ([[], ")"]) and an address (?stack$list["append"]) and push the combined address (?stack$list["append"][[[], ")"]])
  source code:       s->stack = list.append(s->stack, c)
                                ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"], ?stack$list["append"][[ [], ")" ]]]

Step 240:
  program counter:   1074
  hvm code:          Load
  explanation:       pop an address and push the value at the address
  start expression:  line=32 column=14
  end expression:    line=32 column=37
  call trace:        push_test(1, ")") --> push(?s, ")")
  new mode:          failed
  stack:             [{:}, 23426, { "char": ")", "result": None, "self": 1 }, ?s["stack"]]
  operation failed:  Load: unknown address ?stack$list["append"][[[], ")"]]

================================================
Final state
================================================
Threads:
  T0: pc=1558 terminated atomic __init__()
  T1: pc=1448 runnable push_test(1, "(")
  T2: pc=1448 runnable push_test(2, "(")
  T3: pc=1074 failed push_test(1, ")") --> push(?s, ")")
  T4: pc=1477 runnable pop_test(1)
  T5: pc=1500 runnable validate_test()
Variables:
  s: { "ever_negative": False, "max_size": 2, "mutex": True, "pop_gate": { "count": 0, "sema": True }, "problem_index": -1, "push_gate": { "count": 0, "sema": True }, "size": 0, "stack": [], "valid": 0, "validate_gate": { "count": 0, "sema": True } }
