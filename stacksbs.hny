from synch import BinSema, acquire, release



def Stack(l):
  # return an empty stack with maximum size l
  result = {

    # EVERYTHING HERE HAS TO DO WITH BINARY SEMAPHORE LOCKING:
    .mutex: BinSema(False), #main gate
    .push_gate: { .sema: BinSema(True), .count: 0 },
    .pop_gate: { .sema: BinSema(True), .count: 0 },
    .validate_gate: { .sema: BinSema(True), .count: 0 },
    .ncs: 0 #number of people in critical section

    # EVERYTHING HERE HAS TO DO WITH STACK:
    .stack: {.top: None}
    .size: 0, # how do we make sure the max size is l
    .max_size: l, # capture maxSize parameter
    .valid: 0,#+1 to this when '(' and -1 when ')'
    .ever_negative: False, #whenever pushing, check after if valid is negative and if so make True

  }

def push(s, c):
  # wait until the stack is not full, then push c onto !s
  acquire(?s->mutex)
  if (?s->ncs > 0):
    ?s->push_gate.count += 1
    release_one(s)
    acquire(?s->push_gate.sema)
    ?s->push_gate.count -= 1
    
  ?s->ncs += 1

  # BEGIN push logic
  let node = malloc({ .value: v, .next: None }):
          node->next = s->top
          s->top = node
  # END push logic

  release_one(s)

def pop(s):
  # wait until a stack is non-empty and then remove and return the top of the stack
  acquire(?s->mutex)
  if (?s->ncs > 0):
    ?s->pop_gate.count += 1
    release_one(s)
    acquire(?s->pop_gate.sema)
    ?s->pop_gate.count -= 1
    
  ?s->ncs += 1
  
  # BEGIN pop logic
  let node = s->top:
      if s->top == None:
          result = None
      else:
          result = s->top->value
          s->top = s->top->next
          free(node)
  # END pop logic
  
  release_one(s)

def validate(s):
  # wait until stack !s is full, then check if its valid
  acquire(?s->mutex)
  if (?s->ncs > 0):
    ?s->validate_gate.count += 1
    release_one(s)
    acquire(?s->validate_gate.sema)
    ?s->validate_gate.count -= 1

  ?s->ncs += 1
  
  # BEGIN validation logic

  # END validation logic

  release_one(s)

def release_one(s):
  if (?s->ncs == 0 && ?s->size != ?s ->maxsize && ?s->push_gate.count > 0):
    release(?s->push_gate.sema)
  elif (?s->ncs == 0 && ?s->size != 0 && ?s->pop_gate.count > 0):
    release(?s->pop_gate.sema)
  elif (?s->ncs == 0 && ?s->size == ?s ->maxsize && ?s->validate_gate.count > 0):
    release(?s->validate_gate.sema)
  else:
    release(?s->mutex)